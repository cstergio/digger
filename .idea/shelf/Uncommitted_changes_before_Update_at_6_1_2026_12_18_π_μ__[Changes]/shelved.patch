Index: client/views/scenes/how_to_play_scene.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/scenes/how_to_play_scene.py b/client/views/scenes/how_to_play_scene.py
--- a/client/views/scenes/how_to_play_scene.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/scenes/how_to_play_scene.py	(date 1767633522055)
@@ -1,0 +1,178 @@
+import pygame
+import os
+from shared.core.scene import Scene
+
+
+class HowToPlayScene(Scene):
+    """
+    Σκηνή οδηγιών παιχνιδιού (How To Play).
+
+    Παρουσιάζει στον παίκτη:
+    - σύντομη περιγραφή gameplay
+    - στόχους παιχνιδιού
+    - χειρισμό για Player 1 και Player 2
+    - στοιχεία δημιουργών
+
+    Η σκηνή είναι παθητική (μόνο ανάγνωση) και
+    επιστρέφει στο main menu με ESC.
+    """
+
+    def __init__(self, scene_manager):
+        # Αναφορά στον SceneManager για αλλαγή σκηνής
+        self.sm = scene_manager
+
+        # -------------------------
+        # Paths για assets
+        # -------------------------
+        base_dir = os.path.dirname(__file__)
+        assets_dir = os.path.join(base_dir, "..", "..", "assets")
+        fonts_dir = os.path.join(assets_dir, "fonts")
+        menu_dir = os.path.join(assets_dir, "menu")
+
+        # -------------------------
+        # Background εικόνα
+        # -------------------------
+        # Χρησιμοποιείται ξεχωριστό background από το main menu
+        self.bg = pygame.image.load(
+            os.path.join(menu_dir, "menu_bg2.png")
+        ).convert()
+
+        # -------------------------
+        # Fonts
+        # -------------------------
+        # Τίτλος (μεγαλύτερο μέγεθος)
+        self.font_title = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 44
+        )
+
+        # Κείμενο οδηγιών (μικρό μέγεθος για να χωράει)
+        self.font = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 18
+        )
+
+        # -------------------------
+        # Input handling
+        # -------------------------
+        # Cooldown ώστε να μη γίνεται άμεση επιστροφή με ESC
+        self._cooldown = 0.3
+
+        # Τελευταίο InputSnapshot
+        self._input = None
+
+    # ===============================
+    # Scene interface
+    # ===============================
+
+    def enter(self, payload=None):
+        """
+        Καλείται όταν η σκηνή ενεργοποιείται.
+
+        Επαναφέρει το cooldown για ασφαλή είσοδο.
+        """
+        self._cooldown = 0.3
+
+    def exit(self):
+        """
+        Καλείται όταν η σκηνή απενεργοποιείται.
+        Δεν απαιτείται καθαρισμός πόρων.
+        """
+        pass
+
+    def handle_input(self, input_snapshot):
+        """
+        Αποθηκεύει το input του τρέχοντος frame.
+        """
+        self._input = input_snapshot
+
+    # ===============================
+    # Update
+    # ===============================
+
+    def update(self, dt):
+        """
+        Ελέγχει αν ο παίκτης πάτησε ESC για επιστροφή
+        στο main menu, αφού περάσει το cooldown.
+        """
+
+        # Μείωση cooldown με βάση τον χρόνο frame
+        self._cooldown = max(0.0, self._cooldown - dt)
+
+        # Αν το cooldown δεν έχει λήξει, δεν κάνουμε τίποτα
+        if self._cooldown > 0:
+            return
+
+        # ESC → επιστροφή στο main menu
+        if self._input and self._input.pause:
+            self.sm.set_scene("menu", {})
+
+    # ===============================
+    # Render
+    # ===============================
+
+    def render(self, surface):
+        """
+        Σχεδίαση της σκηνής οδηγιών.
+        """
+
+        # Background
+        surface.blit(self.bg, (0, 0))
+
+        w, h = surface.get_width(), surface.get_height()
+
+        # -------------------------
+        # Τίτλος
+        # -------------------------
+        title = "HOW TO PLAY"
+        title_surf = self.font_title.render(title, True, (255, 255, 255))
+        surface.blit(
+            title_surf,
+            (w // 2 - title_surf.get_width() // 2, 60)
+        )
+
+        # -------------------------
+        # Κείμενο οδηγιών
+        # -------------------------
+        # Αρχική θέση κειμένου κάτω από τον τίτλο
+        y = 60 + title_surf.get_height() + 16
+
+        # Μικρό line spacing ώστε να χωράει όλο το κείμενο
+        line_spacing = 4
+
+        # Κείμενο χωρισμένο σε γραμμές
+        text_lines = [
+            "You control the Digger, exploring an underground maze",
+            "of tunnels while collecting emeralds and avoiding enemies.",
+            "",
+            "Dig through dirt, drop gold bags to crush enemies,",
+            "and use your weapon wisely to survive.",
+            "",
+            "Clear all emeralds to advance to the next level.",
+            "If you lose all your lives, the game is over.",
+            "",
+            "CONTROLS",
+            "Arrow Keys  : Move",
+            "SPACE       : Fire weapon",
+            "ESC         : Back to Menu",
+            "",
+            "Player 2 (Co-op)",
+            "W A S D     : Move",
+            "LEFT SHIFT : Fire",
+            "",
+            "CREATED BY",
+            "Konstantinos Gaitanis",
+            "Charalampos Stergiopoulos Roubas",
+        ]
+
+        # Σχεδίαση κάθε γραμμής
+        for line in text_lines:
+            surf = self.font.render(line, True, (230, 230, 230))
+            surface.blit(
+                surf,
+                (w // 2 - surf.get_width() // 2, y)
+            )
+
+            # Αν η γραμμή είναι κενή, μικρότερο κενό (παράγραφος)
+            if line.strip() == "":
+                y += surf.get_height() // 3
+            else:
+                y += surf.get_height() + line_spacing
Index: shared/model/bullet.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/bullet.py b/shared/model/bullet.py
--- a/shared/model/bullet.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/bullet.py	(date 1767632320865)
@@ -1,0 +1,70 @@
+from shared.model.types import Direction
+# Εισαγωγή του Enum Direction,
+# το οποίο ορίζει προς ποια κατεύθυνση κινείται η σφαίρα
+# (UP, DOWN, LEFT, RIGHT)
+
+
+class Bullet:
+    """
+    Κλάση που αναπαριστά μία σφαίρα (projectile).
+
+    Η σφαίρα:
+    - ξεκινά από τη θέση του παίκτη
+    - κινείται σε μία σταθερή κατεύθυνση
+    - έχει περιορισμένη διάρκεια ζωής
+    - εξαφανίζεται είτε με τον χρόνο είτε αν συγκρουστεί
+    """
+
+    def __init__(self, tile_x: int, tile_y: int, direction: Direction):
+        # Αρχική θέση της σφαίρας στο grid (σε tiles)
+        self.tile_x = tile_x
+        self.tile_y = tile_y
+
+        # Κατεύθυνση κίνησης της σφαίρας
+        # Η κατεύθυνση ορίζεται τη στιγμή που πυροβολεί ο παίκτης
+        self.direction = direction
+
+        # Μέγιστη διάρκεια ζωής της σφαίρας (σε δευτερόλεπτα)
+        # Μετά από αυτό το χρονικό διάστημα η σφαίρα "λήγει"
+        self.life_time = 0.8
+
+        # Χρόνος που έχει περάσει από τη δημιουργία της σφαίρας
+        self._age = 0.0
+
+        # Χρονόμετρο για το απλό animation (flicker)
+        # Χρησιμοποιείται για να αναβοσβήνει η σφαίρα
+        self._anim_timer = 0.0
+
+        # Ορίζει αν η σφαίρα είναι ορατή στο συγκεκριμένο frame
+        # Αλλάζει τιμή ώστε να δημιουργείται arcade αίσθηση
+        self.visible = True
+
+    def update(self, dt: float):
+        """
+        Ενημέρωση της κατάστασης της σφαίρας ανά frame.
+
+        Το dt είναι ο χρόνος που πέρασε από το προηγούμενο frame.
+        """
+
+        # Αύξηση της "ηλικίας" της σφαίρας
+        self._age += dt
+
+        # Αύξηση του timer για το animation
+        self._anim_timer += dt
+
+        # Απλό εφέ αναβοσβησίματος (flicker)
+        # Κάθε 0.05 δευτερόλεπτα αλλάζει η ορατότητα
+        if self._anim_timer >= 0.05:
+            self.visible = not self.visible
+            self._anim_timer = 0.0
+
+    @property
+    def expired(self) -> bool:
+        """
+        Επιστρέφει True αν η σφαίρα έχει ξεπεράσει
+        τον επιτρεπτό χρόνο ζωής της.
+
+        Χρησιμοποιείται από το BulletSystem
+        για να αφαιρεί παλιές σφαίρες.
+        """
+        return self._age >= self.life_time
Index: shared/model/score.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/score.py b/shared/model/score.py
--- a/shared/model/score.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/score.py	(date 1767631971273)
@@ -1,0 +1,66 @@
+class Score:
+    """
+    Κλάση που διαχειρίζεται το σκορ του παίκτη.
+    Περιλαμβάνει:
+    - συνολικούς πόντους
+    - combo συλλογής διαμαντιών
+    - πόντους από εξόντωση εχθρών
+    """
+
+    def __init__(self):
+        # Συνολικοί πόντοι του παίκτη
+        self.points = 0
+
+        # Μετρητής combo για συνεχόμενη συλλογή emeralds
+        self.combo = 0
+
+    def add_points(self, pts):
+        """
+        Προσθέτει απλούς πόντους στο σκορ.
+        Χρησιμοποιείται για γενικές περιπτώσεις (π.χ. bonus, gold).
+        """
+        self.points += pts
+
+    def add_emerald(self):
+        """
+        Καλείται όταν ο παίκτης συλλέγει ένα emerald.
+        - Προσθέτει βασικούς πόντους
+        - Αυξάνει το combo
+        - Αν συμπληρωθεί combo 8 emeralds, δίνει bonus
+        """
+
+        # Κάθε emerald δίνει 25 πόντους
+        self.points += 25
+
+        # Αύξηση του combo μετρητή
+        self.combo += 1
+
+        # Αν ο παίκτης μαζέψει 8 emeralds στη σειρά
+        if self.combo == 8:
+            # Bonus πόντοι για πλήρες combo
+            self.points += 250
+
+            # Επαναφορά combo στο μηδέν
+            self.combo = 0
+
+    def reset_combo(self):
+        """
+        Επαναφέρει το combo.
+        Χρησιμοποιείται όταν ο παίκτης χτυπηθεί
+        ή διακοπεί η αλυσίδα συλλογής.
+        """
+        self.combo = 0
+
+    def eat_enemy(self, chain):
+        """
+        Υπολογίζει πόντους από εξόντωση εχθρού με βάση αλυσίδα (chain).
+        Όσο μεγαλύτερο το chain, τόσο περισσότεροι οι πόντοι.
+
+        Παράδειγμα:
+        chain = 0 -> 200 πόντοι
+        chain = 1 -> 400 πόντοι
+        chain = 2 -> 800 πόντοι
+        """
+
+        # Εκθετική αύξηση πόντων με βάση το chain
+        self.points += 200 * (2 ** chain)
Index: shared/model/enemy.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/enemy.py b/shared/model/enemy.py
--- a/shared/model/enemy.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/enemy.py	(date 1767632271294)
@@ -1,0 +1,50 @@
+from shared.model.entity import Entity
+# Εισαγωγή της βασικής κλάσης Entity,
+# από την οποία κληρονομούν όλες οι οντότητες του παιχνιδιού
+# που έχουν θέση στο grid και κατάσταση ζωής.
+
+from shared.model.types import MonsterForm
+# Εισαγωγή του Enum MonsterForm,
+# το οποίο ορίζει τις μορφές του εχθρού (NOBBIN / HOBBIN)
+
+
+class Enemy(Entity):
+    """
+    Κλάση που αναπαριστά έναν εχθρό του παιχνιδιού.
+
+    Ο εχθρός έχει δύο μορφές:
+    - NOBBIN: κινείται μόνο μέσα σε υπάρχοντα tunnels
+    - HOBBIN: μπορεί να σκάβει το χώμα (DIRT -> TUNNEL)
+
+    Η αλλαγή μορφής γίνεται δυναμικά κατά τη διάρκεια του παιχνιδιού
+    μέσω ειδικού συστήματος (EnemyFormSystem).
+    """
+
+    def __init__(self, entity_id: str, tile_x: int, tile_y: int):
+        # Κλήση του constructor της βασικής κλάσης Entity
+        # Αρχικοποιεί:
+        # - entity_id
+        # - tile_x
+        # - tile_y
+        # - dir
+        # - alive
+        super().__init__(entity_id, tile_x, tile_y)
+
+        # Κατάσταση ζωής του εχθρού
+        # True  -> ο εχθρός είναι ενεργός
+        # False -> ο εχθρός έχει σκοτωθεί
+        self.alive = True
+
+        # Τρέχουσα μορφή του εχθρού
+        # Ξεκινά πάντα ως NOBBIN
+        self.form = MonsterForm.NOBBIN
+
+        # Χρονόμετρο που μετρά πόσο χρόνο
+        # ο εχθρός βρίσκεται στην τρέχουσα μορφή
+        # Χρησιμοποιείται για την εναλλαγή NOBBIN <-> HOBBIN
+        self.form_timer = 0.0
+
+        # Ανεξάρτητο χρονόμετρο κίνησης του εχθρού
+        # Επιτρέπει στους εχθρούς να κινούνται
+        # με διαφορετική ταχύτητα από τον παίκτη
+        self.move_timer = 0.0
Index: shared/model/gold_bag.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/gold_bag.py b/shared/model/gold_bag.py
--- a/shared/model/gold_bag.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/gold_bag.py	(date 1767632186734)
@@ -1,0 +1,44 @@
+from shared.model.entity import Entity
+# Εισαγωγή της βασικής κλάσης Entity.
+# (Ακόμα κι αν δεν χρησιμοποιείται άμεσα εδώ, δείχνει ότι
+# το GoldBag ανήκει στο ίδιο εννοιολογικό μοντέλο οντοτήτων του παιχνιδιού.)
+
+
+class GoldBag:
+    """
+    Κλάση που αναπαριστά έναν σάκο χρυσού (gold bag) στο παιχνίδι.
+
+    Ο σάκος:
+    - ξεκινά ως σταθερό αντικείμενο
+    - μπορεί να πέσει κατακόρυφα
+    - μπορεί να μετατραπεί σε χρυσό (gold pile)
+    - μπορεί να συλλεχθεί από παίκτη ή εχθρό
+    """
+
+    def __init__(self, bag_id: str, tile_x: int, tile_y: int):
+        # Μοναδικό αναγνωριστικό του σάκου
+        # Χρησιμοποιείται από συστήματα (π.χ. timers πτώσης)
+        self.id = bag_id
+
+        # Θέση του σάκου στο grid του επιπέδου (σε tiles)
+        self.tile_x = tile_x
+        self.tile_y = tile_y
+
+        # Αποθηκεύει την προηγούμενη κατακόρυφη θέση του σάκου
+        # Χρησιμοποιείται για να ελεγχθεί αν ο σάκος
+        # διέσχισε κάποιον εχθρό κατά την πτώση του
+        self.prev_tile_y = tile_y
+
+        # Δηλώνει αν ο σάκος βρίσκεται σε κατάσταση πτώσης
+        # True  -> πέφτει
+        # False -> είναι σταθερός
+        self.falling = False
+
+        # Δηλώνει αν ο σάκος έχει "σπάσει" και έχει μετατραπεί σε χρυσό
+        # False -> κανονικός σάκος
+        # True  -> gold pile (δίνει πόντους)
+        self.is_gold = False
+
+        # Δηλώνει αν ο σάκος έχει συλλεχθεί
+        # Όταν γίνει True, ο σάκος δεν αλληλεπιδρά πλέον με το παιχνίδι
+        self.collected = False
Index: client/views/sprites/player_sprite.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport os\r\n\r\nclass PlayerSprite:\r\n    FRAME_SIZE = 32\r\n    ANIM_SPEED = 0.12  # seconds per frame\r\n\r\n    def __init__(self):\r\n        base_dir = os.path.dirname(__file__)\r\n        sprite_path = os.path.join(\r\n            base_dir, \"..\", \"..\", \"assets\", \"sprites\", \"digger_player.png\"\r\n        )\r\n\r\n        sheet = pygame.image.load(sprite_path).convert_alpha()\r\n\r\n        self.frames = []\r\n        for i in range(4):\r\n            frame = sheet.subsurface(\r\n                pygame.Rect(i * 32, 0, 32, 32)\r\n            )\r\n            self.frames.append(frame)\r\n\r\n        self.frame_index = 0\r\n        self.timer = 0.0\r\n\r\n    def update(self, dt, moving: bool):\r\n        if not moving:\r\n            self.frame_index = 0\r\n            self.timer = 0.0\r\n            return\r\n\r\n        self.timer += dt\r\n        if self.timer >= self.ANIM_SPEED:\r\n            self.timer = 0.0\r\n            self.frame_index = (self.frame_index + 1) % len(self.frames)\r\n\r\n    def draw(self, surface, x, y):\r\n        surface.blit(self.frames[self.frame_index], (x, y))\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/sprites/player_sprite.py b/client/views/sprites/player_sprite.py
--- a/client/views/sprites/player_sprite.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/sprites/player_sprite.py	(date 1767632837641)
@@ -1,38 +1,79 @@
 import pygame
 import os
+from shared.model.types import Direction
+
 
 class PlayerSprite:
-    FRAME_SIZE = 32
-    ANIM_SPEED = 0.12  # seconds per frame
+    """
+    Κλάση υπεύθυνη για την ΟΠΤΙΚΗ αναπαράσταση του παίκτη.
+
+    Δεν περιέχει καμία λογική κίνησης, σύγκρουσης ή gameplay.
+    Ασχολείται αποκλειστικά με:
+    - φόρτωση του sprite
+    - περιστροφή / αναστροφή του sprite
+    - σχεδίαση στην οθόνη
+    """
+
+    # Σταθερό μέγεθος sprite σε pixels (32x32)
+    SIZE = 32
 
     def __init__(self):
+        # Υπολογισμός διαδρομών φακέλων
         base_dir = os.path.dirname(__file__)
-        sprite_path = os.path.join(
-            base_dir, "..", "..", "assets", "sprites", "digger_player.png"
+        assets_dir = os.path.join(
+            base_dir, "..", "..", "assets", "sprites"
         )
 
-        sheet = pygame.image.load(sprite_path).convert_alpha()
+        # Πλήρης διαδρομή του αρχείου sprite του παίκτη
+        sprite_path = os.path.join(assets_dir, "digger_player.png")
+
+        # --------------------------------------------------
+        # Φόρτωση βασικού sprite
+        # Θεωρούμε ότι το αρχικό sprite "κοιτάει" προς τα ΔΕΞΙΑ
+        # --------------------------------------------------
+        self.base_image = pygame.image.load(sprite_path).convert_alpha()
 
-        self.frames = []
-        for i in range(4):
-            frame = sheet.subsurface(
-                pygame.Rect(i * 32, 0, 32, 32)
-            )
-            self.frames.append(frame)
+        # --------------------------------------------------
+        # Κλιμάκωση sprite για ασφάλεια
+        # (εξασφαλίζει ότι είναι ακριβώς 32x32)
+        # --------------------------------------------------
+        self.base_image = pygame.transform.scale(
+            self.base_image, (self.SIZE, self.SIZE)
+        )
+
+    def draw(self, surface, x, y, direction):
+        """
+        Σχεδιάζει το sprite του παίκτη στην οθόνη.
+
+        surface   : pygame Surface (οθόνη ή υπο-οθόνη)
+        x, y      : συντεταγμένες οθόνης (screen coordinates)
+        direction : κατεύθυνση που κοιτάει ο παίκτης
+        """
+
+        # Από προεπιλογή χρησιμοποιούμε το βασικό sprite
+        image = self.base_image
 
-        self.frame_index = 0
-        self.timer = 0.0
+        # --------------------------------------------------
+        # Μετασχηματισμός sprite ανάλογα με την κατεύθυνση
+        # --------------------------------------------------
 
-    def update(self, dt, moving: bool):
-        if not moving:
-            self.frame_index = 0
-            self.timer = 0.0
-            return
+        # Αν ο παίκτης κοιτάει αριστερά, κάνουμε οριζόντια αναστροφή
+        if direction == Direction.LEFT:
+            image = pygame.transform.flip(self.base_image, True, False)
 
-        self.timer += dt
-        if self.timer >= self.ANIM_SPEED:
-            self.timer = 0.0
-            self.frame_index = (self.frame_index + 1) % len(self.frames)
+        # Αν κοιτάει προς τα πάνω, περιστρέφουμε 90 μοίρες
+        elif direction == Direction.UP:
+            image = pygame.transform.rotate(self.base_image, 90)
 
-    def draw(self, surface, x, y):
-        surface.blit(self.frames[self.frame_index], (x, y))
+        # Αν κοιτάει προς τα κάτω, περιστρέφουμε -90 μοίρες
+        elif direction == Direction.DOWN:
+            image = pygame.transform.rotate(self.base_image, -90)
+
+        # Direction.RIGHT:
+        # Δεν χρειάζεται καμία αλλαγή, γιατί το sprite
+        # έχει σχεδιαστεί αρχικά προς τα δεξιά
+
+        # --------------------------------------------------
+        # Τελική σχεδίαση του sprite στην οθόνη
+        # --------------------------------------------------
+        surface.blit(image, (x, y))
Index: shared/model/player.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/player.py b/shared/model/player.py
--- a/shared/model/player.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/player.py	(date 1767632035110)
@@ -1,0 +1,29 @@
+from shared.model.types import Direction
+# Εισαγωγή του Enum Direction, το οποίο χρησιμοποιείται
+# για να δηλώνει προς ποια κατεύθυνση κοιτάζει ή κινείται ο παίκτης
+
+
+class Player:
+    """
+    Κλάση που αναπαριστά έναν παίκτη στο παιχνίδι.
+    Περιέχει μόνο την ΚΑΤΑΣΤΑΣΗ του παίκτη (position, direction, alive)
+    και ΟΧΙ τη λογική κίνησης ή αλληλεπίδρασης.
+    """
+
+    def __init__(self, player_id: str, tile_x: int, tile_y: int):
+        # Μοναδικό αναγνωριστικό παίκτη (π.χ. "p1", "p2")
+        self.id = player_id
+
+        # Συντεταγμένες του παίκτη στο grid του επιπέδου (σε tiles)
+        self.tile_x = tile_x
+        self.tile_y = tile_y
+
+        # Κατεύθυνση προς την οποία "κοιτάζει" ο παίκτης
+        # Χρησιμοποιείται κυρίως από το σύστημα όπλου
+        # Είναι None όταν ο παίκτης δεν έχει κινηθεί ακόμα
+        self.direction: Direction | None = None
+
+        # Κατάσταση ζωής του παίκτη
+        # True  -> ο παίκτης είναι ενεργός στο παιχνίδι
+        # False -> ο παίκτης έχει πεθάνει (π.χ. στο game over ή co-op)
+        self.alive = True
Index: shared/model/types.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/types.py b/shared/model/types.py
--- a/shared/model/types.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/types.py	(date 1767631882539)
@@ -1,0 +1,76 @@
+from enum import Enum, auto
+# Εισαγωγή της κλάσης Enum για τη δημιουργία απαριθμήσεων (enumerations)
+# και της συνάρτησης auto(), ώστε οι τιμές να εκχωρούνται αυτόματα.
+
+# ==================================================
+# Κατευθύνσεις κίνησης
+# ==================================================
+class Direction(Enum):
+    # Κατεύθυνση προς τα πάνω
+    UP = auto()
+
+    # Κατεύθυνση προς τα κάτω
+    DOWN = auto()
+
+    # Κατεύθυνση προς τα αριστερά
+    LEFT = auto()
+
+    # Κατεύθυνση προς τα δεξιά
+    RIGHT = auto()
+
+    # Καμία κατεύθυνση (π.χ. όταν ο παίκτης δεν κινείται)
+    NONE = auto()
+
+
+# ==================================================
+# Τύποι πλακιδίων (tiles) του επιπέδου
+# ==================================================
+class TileType(Enum):
+    # Κενό tile (δεν περιέχει κάτι)
+    EMPTY = auto()
+
+    # Χώμα, το οποίο μπορεί να σκαφτεί
+    DIRT = auto()
+
+    # Σήραγγα (διάδρομος κίνησης)
+    TUNNEL = auto()
+
+    # Διαμάντι που συλλέγεται για πόντους
+    EMERALD = auto()      # θα χρησιμοποιηθεί στο Βήμα 6
+
+    # Σάκος χρυσού που μπορεί να πέσει
+    GOLD_BAG = auto()
+
+    # Σωρός χρυσού μετά την πτώση του σάκου
+    GOLD_PILE = auto()
+
+    # Bonus αντικείμενο (π.χ. cherry)
+    CHERRY = auto()
+
+    # Σημείο εμφάνισης (spawn) του Player 1
+    SPAWN_P1 = auto()
+
+
+# ==================================================
+# Μορφή εχθρού
+# ==================================================
+class MonsterForm(Enum):
+    # Κανονική μορφή εχθρού (δεν σκάβει χώμα)
+    NOBBIN = auto()
+
+    # Επιθετική μορφή εχθρού (σκάβει χώμα)
+    HOBBIN = auto()
+
+
+# ==================================================
+# Κατάσταση παιχνιδιού (game mode)
+# ==================================================
+class GameMode(Enum):
+    # Κανονική ροή παιχνιδιού
+    NORMAL = auto()
+
+    # Bonus mode (π.χ. περιορισμένος χρόνος, έξτρα πόντοι)
+    BONUS = auto()
+
+    # Ολοκλήρωση πίστας πριν τη μετάβαση στην επόμενη
+    LEVEL_COMPLETE = auto()
Index: client/views/sprites/emerald_sprite.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/sprites/emerald_sprite.py b/client/views/sprites/emerald_sprite.py
--- a/client/views/sprites/emerald_sprite.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/sprites/emerald_sprite.py	(date 1767633051766)
@@ -1,0 +1,63 @@
+import pygame
+import os
+
+
+class EmeraldSprite:
+    """
+    Κλάση υπεύθυνη για την οπτική αναπαράσταση του emerald (διαμάντι).
+
+    Η κλάση αυτή:
+    - δεν περιέχει καμία λογική gameplay
+    - δεν γνωρίζει τίποτα για score ή συλλογή
+    - έχει αποκλειστική ευθύνη τη φόρτωση και σχεδίαση του sprite
+
+    Ανήκει καθαρά στο View layer της εφαρμογής.
+    """
+
+    def __init__(self):
+        # --------------------------------------------------
+        # Εντοπισμός του φακέλου του αρχείου με ασφάλεια
+        # --------------------------------------------------
+        # base_dir: ο φάκελος όπου βρίσκεται το αρχείο emerald_sprite.py
+        base_dir = os.path.dirname(__file__)
+
+        # --------------------------------------------------
+        # Δημιουργία πλήρους διαδρομής προς το emerald sprite
+        # --------------------------------------------------
+        # Με το os.path.join αποφεύγουμε προβλήματα σε διαφορετικά λειτουργικά
+        sprite_path = os.path.join(
+            base_dir,
+            "..", "..",
+            "assets", "sprites", "emerald.png"
+        )
+
+        # --------------------------------------------------
+        # Φόρτωση της εικόνας emerald
+        # --------------------------------------------------
+        # convert_alpha():
+        # - επιτρέπει διαφάνεια (alpha channel)
+        # - βελτιώνει την απόδοση στο blitting
+        self.image = pygame.image.load(sprite_path).convert_alpha()
+
+        # --------------------------------------------------
+        # Κλιμάκωση εικόνας σε 32x32 pixels
+        # --------------------------------------------------
+        # Το μέγεθος αυτό αντιστοιχεί σε ένα tile του παιχνιδιού
+        self.image = pygame.transform.scale(self.image, (32, 32))
+
+    def draw(self, surface, x, y):
+        """
+        Σχεδιάζει το emerald στην οθόνη.
+
+        surface : pygame Surface (κύρια οθόνη ή υπο-επιφάνεια)
+        x, y    : συντεταγμένες οθόνης (screen coordinates)
+
+        Σημείωση:
+        - Οι συντεταγμένες έχουν ήδη μετατραπεί από world → screen
+        - Η κλάση Camera ΔΕΝ εμπλέκεται εδώ
+        """
+
+        # --------------------------------------------------
+        # Σχεδίαση της εικόνας στην επιφάνεια
+        # --------------------------------------------------
+        surface.blit(self.image, (x, y))
Index: client/views/scenes/highscores_scene.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/scenes/highscores_scene.py b/client/views/scenes/highscores_scene.py
--- a/client/views/scenes/highscores_scene.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/scenes/highscores_scene.py	(date 1767633583824)
@@ -1,0 +1,139 @@
+import pygame
+import os
+from shared.core.scene import Scene
+from shared.persistence.score_repository import ScoreRepository
+
+
+class HighScoresScene(Scene):
+    """
+    Σκηνή εμφάνισης High Scores.
+
+    Εμφανίζει τις 10 καλύτερες βαθμολογίες που είναι
+    αποθηκευμένες στη βάση δεδομένων (SQLite).
+
+    Η σκηνή:
+    - δεν έχει επιλογές / μενού
+    - λειτουργεί μόνο ως προβολή δεδομένων
+    - επιστρέφει στο main menu με το πλήκτρο ESC
+    """
+
+    def __init__(self, scene_manager):
+        # Αναφορά στον SceneManager για αλλαγή σκηνών
+        self.sm = scene_manager
+
+        # Repository για πρόσβαση στη βάση δεδομένων scores
+        self.repo = ScoreRepository()
+
+        # Αποθήκευση του τελευταίου InputSnapshot
+        self._input = None
+
+        # -------------------------
+        # Paths για assets
+        # -------------------------
+        base_dir = os.path.dirname(__file__)
+        assets_dir = os.path.join(base_dir, "..", "..", "assets")
+        fonts_dir = os.path.join(assets_dir, "fonts")
+        menu_dir = os.path.join(assets_dir, "menu")
+
+        # -------------------------
+        # Background εικόνα
+        # -------------------------
+        # Χρησιμοποιείται το ίδιο background με το main menu
+        self.bg = pygame.image.load(
+            os.path.join(menu_dir, "menu_bg.png")
+        ).convert()
+
+        # -------------------------
+        # Fonts
+        # -------------------------
+        # Τίτλος High Scores
+        self.font_title = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 48
+        )
+
+        # Κείμενο βαθμολογιών
+        self.font = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 22
+        )
+
+    # ==================================================
+    # REQUIRED by abstract Scene
+    # ==================================================
+
+    def enter(self, payload=None):
+        """
+        Καλείται όταν η σκηνή ενεργοποιείται.
+        Δεν απαιτείται αρχικοποίηση κατά την είσοδο.
+        """
+        pass
+
+    def exit(self):
+        """
+        Καλείται όταν η σκηνή απενεργοποιείται.
+        Δεν απαιτείται καθαρισμός πόρων.
+        """
+        pass
+
+    def handle_input(self, input_snapshot):
+        """
+        Αποθηκεύει το input του τρέχοντος frame.
+        """
+        self._input = input_snapshot
+
+    def update(self, dt):
+        """
+        Ελέγχει αν ο παίκτης πάτησε ESC
+        ώστε να επιστρέψει στο main menu.
+        """
+
+        if self._input and self._input.pause:
+            self.sm.set_scene("menu", {})
+
+    def render(self, surface):
+        """
+        Σχεδίαση της σκηνής High Scores.
+        """
+
+        # -------------------------
+        # Background
+        # -------------------------
+        surface.blit(self.bg, (0, 0))
+
+        w = surface.get_width()
+
+        # -------------------------
+        # Τίτλος
+        # -------------------------
+        title = self.font_title.render("HIGH SCORES", True, (255, 255, 255))
+
+        # Το +160 χρησιμοποιείται για να ευθυγραμμιστεί
+        # οπτικά με το layout του main menu
+        surface.blit(
+            title,
+            (w // 2 - title.get_width() // 2 + 160, 100)
+        )
+
+        # -------------------------
+        # Ανάκτηση scores από τη βάση
+        # -------------------------
+        scores = self.repo.top_10()
+
+        # -------------------------
+        # Εμφάνιση λίστας
+        # -------------------------
+        y = 200  # αρχικό ύψος πρώτης γραμμής
+
+        for i, (name, date, time, score) in enumerate(scores, start=1):
+            # Μορφοποίηση γραμμής:
+            # θέση, όνομα παιχνιδιού, ημερομηνία, ώρα, σκορ
+            line = f"{i:>2}. {name:<6} {date} {time}   {score:>6}"
+
+            txt = self.font.render(line, True, (230, 230, 230))
+
+            surface.blit(
+                txt,
+                (w // 2 - txt.get_width() // 2 + 160, y)
+            )
+
+            # Μετακίνηση στην επόμενη γραμμή
+            y += 32
Index: shared/core/scene.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/core/scene.py b/shared/core/scene.py
--- a/shared/core/scene.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/core/scene.py	(date 1767632473525)
@@ -1,0 +1,169 @@
+from __future__ import annotations
+from abc import ABC, abstractmethod
+from typing import Optional, Dict
+
+from shared.services.input import InputSnapshot
+
+
+class Scene(ABC):
+    """
+    Αφηρημένη βασική κλάση (Abstract Base Class) για όλες τις σκηνές του παιχνιδιού.
+
+    Ορίζει το «συμβόλαιο» (contract) που ΠΡΕΠΕΙ να ακολουθεί κάθε σκηνή
+    (π.χ. MainMenuScene, GameScene, GameOverScene).
+
+    Με αυτόν τον τρόπο:
+    - εξασφαλίζεται κοινή διεπαφή
+    - το SceneManager μπορεί να διαχειρίζεται όλες τις σκηνές με τον ίδιο τρόπο
+    """
+
+    @abstractmethod
+    def enter(self, payload: Optional[dict] = None) -> None:
+        """
+        Καλείται όταν η σκηνή γίνεται ενεργή.
+
+        payload:
+        - λεξικό με δεδομένα που μεταφέρονται από προηγούμενη σκηνή
+        - π.χ. αριθμός παικτών, scores, ρυθμίσεις
+
+        Κάθε σκηνή χρησιμοποιεί το payload όπως χρειάζεται.
+        """
+        ...
+
+    @abstractmethod
+    def exit(self) -> None:
+        """
+        Καλείται όταν η σκηνή απενεργοποιείται.
+
+        Χρησιμοποιείται για:
+        - καθαρισμό πόρων
+        - reset timers
+        - αποθήκευση κατάστασης αν χρειάζεται
+        """
+        ...
+
+    @abstractmethod
+    def handle_input(self, input_snapshot: InputSnapshot) -> None:
+        """
+        Παραλαμβάνει το στιγμιότυπο εισόδου (InputSnapshot) του τρέχοντος frame.
+
+        Η σκηνή ΔΕΝ διαβάζει απευθείας πληκτρολόγιο input,
+        αλλά βασίζεται σε αυτό το αντικείμενο.
+        """
+        ...
+
+    @abstractmethod
+    def update(self, dt: float) -> None:
+        """
+        Λογική ενημέρωσης της σκηνής.
+
+        dt (delta time):
+        - χρόνος σε δευτερόλεπτα από το προηγούμενο frame
+        - χρησιμοποιείται για timers, κινήσεις, animations
+        """
+        ...
+
+    @abstractmethod
+    def render(self, surface) -> None:
+        """
+        Σχεδίαση (rendering) της σκηνής στην οθόνη.
+
+        surface:
+        - το pygame Surface της κύριας οθόνης
+        """
+        ...
+
+
+class SceneManager:
+    """
+    Διαχειριστής σκηνών (Scene Manager).
+
+    Είναι υπεύθυνος για:
+    - καταχώριση σκηνών
+    - εναλλαγή μεταξύ σκηνών
+    - προώθηση input, update και render στην ενεργή σκηνή
+
+    Αποτελεί κεντρικό κομμάτι της αρχιτεκτονικής του παιχνιδιού.
+    """
+
+    def __init__(self) -> None:
+        # Λεξικό σκηνών: scene_id -> Scene instance
+        self._scenes: Dict[str, Scene] = {}
+
+        # Αναγνωριστικό τρέχουσας σκηνής (π.χ. "menu", "game")
+        self._current_id: Optional[str] = None
+
+        # Αντικείμενο της τρέχουσας σκηνής
+        self._current_scene: Optional[Scene] = None
+
+    def register_scene(self, scene_id: str, scene: Scene) -> None:
+        """
+        Καταχωρεί μία σκηνή στο σύστημα.
+
+        scene_id:
+        - μοναδικό string (π.χ. "menu", "gameover")
+
+        scene:
+        - αντικείμενο που υλοποιεί το Scene interface
+        """
+        if scene_id in self._scenes:
+            # Απαγορεύεται διπλή καταχώριση με ίδιο id
+            raise ValueError(f"Scene id already registered: {scene_id}")
+
+        self._scenes[scene_id] = scene
+
+    def set_scene(self, scene_id: str, payload: Optional[dict] = None) -> None:
+        """
+        Αλλάζει την ενεργή σκηνή.
+
+        Βήματα:
+        1. Καλεί exit() στην προηγούμενη σκηνή (αν υπάρχει)
+        2. Ορίζει τη νέα σκηνή ως ενεργή
+        3. Καλεί enter() στη νέα σκηνή με payload
+        """
+        if scene_id not in self._scenes:
+            raise KeyError(f"Unknown scene id: {scene_id}")
+
+        # Αν υπάρχει ενεργή σκηνή, την απενεργοποιούμε
+        if self._current_scene is not None:
+            self._current_scene.exit()
+
+        # Ορισμός νέας σκηνής
+        self._current_id = scene_id
+        self._current_scene = self._scenes[scene_id]
+
+        # Ενεργοποίηση νέας σκηνής
+        self._current_scene.enter(payload or {})
+
+    def handle_input(self, input_snapshot: InputSnapshot) -> None:
+        """
+        Προωθεί το input snapshot στην ενεργή σκηνή.
+        """
+        if self._current_scene is not None:
+            self._current_scene.handle_input(input_snapshot)
+
+    def update(self, dt: float) -> None:
+        """
+        Προωθεί το update (λογική) στην ενεργή σκηνή.
+        """
+        if self._current_scene is not None:
+            self._current_scene.update(dt)
+
+    def render(self, surface) -> None:
+        """
+        Προωθεί το render στην ενεργή σκηνή.
+        """
+        if self._current_scene is not None:
+            self._current_scene.render(surface)
+
+    @property
+    def current_scene_id(self) -> Optional[str]:
+        """
+        Επιστρέφει το id της τρέχουσας σκηνής.
+
+        Χρήσιμο για:
+        - debugging
+        - conditional λογική
+        - overlays ή diagnostics
+        """
+        return self._current_id
Index: client/views/sprites/gold_bag_sprite.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/sprites/gold_bag_sprite.py b/client/views/sprites/gold_bag_sprite.py
--- a/client/views/sprites/gold_bag_sprite.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/sprites/gold_bag_sprite.py	(date 1767632903657)
@@ -1,0 +1,89 @@
+import pygame
+import os
+
+
+class GoldBagSprite:
+    """
+    Κλάση υπεύθυνη για την ΟΠΤΙΚΗ αναπαράσταση των gold bags.
+
+    Η κλάση αυτή:
+    - δεν περιέχει λογική πτώσης
+    - δεν περιέχει λογική συλλογής
+    - δεν αλλάζει την κατάσταση του αντικειμένου
+
+    Απλώς διαβάζει την ΚΑΤΑΣΤΑΣΗ του gold bag
+    και επιλέγει ποια εικόνα θα σχεδιαστεί.
+    """
+
+    # Σταθερό μέγεθος sprite (32x32 pixels)
+    SIZE = 32
+
+    def __init__(self):
+        # --------------------------------------------------
+        # Εντοπισμός του φακέλου client/ με ασφάλεια
+        # --------------------------------------------------
+        base_dir = os.path.dirname(__file__)
+
+        # Μετακίνηση δύο επίπεδα πάνω ώστε να φτάσουμε στο client/
+        client_dir = os.path.abspath(
+            os.path.join(base_dir, "..", "..")
+        )
+
+        # Φάκελος sprites
+        assets_dir = os.path.join(client_dir, "assets", "sprites")
+
+        # --------------------------------------------------
+        # Φόρτωση εικόνων gold bag
+        # --------------------------------------------------
+
+        # Κανονικός σάκος χρυσού (σταθερός)
+        self.bag_image = pygame.image.load(
+            os.path.join(assets_dir, "gold_sack.png")
+        ).convert_alpha()
+
+        # Σάκος χρυσού σε κατάσταση πτώσης
+        self.falling_image = pygame.image.load(
+            os.path.join(assets_dir, "gold_sack_fall.png")
+        ).convert_alpha()
+
+        # Gold pile (όταν σπάσει ο σάκος)
+        self.gold_image = pygame.image.load(
+            os.path.join(assets_dir, "gold_pile.png")
+        ).convert_alpha()
+
+    def draw(self, surface, bag, sx, sy):
+        """
+        Σχεδιάζει το gold bag στην οθόνη.
+
+        surface : pygame Surface (οθόνη ή υπο-οθόνη)
+        bag     : αντικείμενο GoldBag (κατάσταση gameplay)
+        sx, sy  : συντεταγμένες οθόνης (screen coordinates)
+        """
+
+        # --------------------------------------------------
+        # Αν το gold bag έχει συλλεχθεί,
+        # δεν σχεδιάζεται τίποτα
+        # --------------------------------------------------
+        if bag.collected:
+            return
+
+        # --------------------------------------------------
+        # Αν έχει μετατραπεί σε gold pile,
+        # σχεδιάζουμε την εικόνα του χρυσού
+        # --------------------------------------------------
+        if bag.is_gold:
+            surface.blit(self.gold_image, (sx, sy))
+            return
+
+        # --------------------------------------------------
+        # Αν βρίσκεται σε πτώση,
+        # σχεδιάζουμε το falling sprite
+        # --------------------------------------------------
+        if bag.falling:
+            surface.blit(self.falling_image, (sx, sy))
+            return
+
+        # --------------------------------------------------
+        # Διαφορετικά, σχεδιάζουμε τον κανονικό σάκο
+        # --------------------------------------------------
+        surface.blit(self.bag_image, (sx, sy))
Index: client/main.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/main.py b/client/main.py
--- a/client/main.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/main.py	(date 1767632602996)
@@ -1,0 +1,29 @@
+from client.app import GameApp
+
+
+def main() -> None:
+    """
+    Κύρια συνάρτηση εκκίνησης του παιχνιδιού.
+
+    Δημιουργεί ένα αντικείμενο GameApp και ξεκινά
+    τον κεντρικό βρόχο εκτέλεσης (game loop).
+
+    Ο διαχωρισμός σε main() ακολουθεί καλή πρακτική:
+    - επιτρέπει ευκολότερο testing
+    - αποφεύγει εκτέλεση κώδικα κατά το import
+    """
+    GameApp().run()
+
+
+if __name__ == "__main__":
+    """
+    Έλεγχος αν το αρχείο εκτελείται απευθείας
+    και όχι αν έχει εισαχθεί (import) από άλλο αρχείο.
+
+    Μόνο σε αυτή την περίπτωση:
+    - καλείται η main()
+    - ξεκινά το παιχνίδι
+
+    Αυτό είναι το τυπικό entry point μιας Python εφαρμογής.
+    """
+    main()
Index: client/controllers/input_controller.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/controllers/input_controller.py b/client/controllers/input_controller.py
--- a/client/controllers/input_controller.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/controllers/input_controller.py	(date 1767633272883)
@@ -1,0 +1,79 @@
+import pygame
+from shared.services.input import InputSnapshot
+
+
+class InputController:
+    """
+    Η κλάση InputController είναι υπεύθυνη για:
+    - την ανάγνωση της τρέχουσας κατάστασης εισόδου από το pygame
+    - τη δημιουργία και επιστροφή ενός InputSnapshot
+
+    Σε αντίθεση με έναν event-based InputManager,
+    εδώ χρησιμοποιούμε:
+    - polling (pygame.key.get_pressed)
+    - ελάχιστη χρήση events (TEXTINPUT, BACKSPACE, QUIT)
+
+    Ο στόχος είναι κάθε frame να παράγεται
+    ένα πλήρες και συνεπές snapshot εισόδου.
+    """
+
+    def capture(self) -> InputSnapshot:
+        """
+        Συλλέγει την είσοδο του χρήστη για το τρέχον frame
+        και επιστρέφει ένα νέο InputSnapshot.
+
+        Το snapshot αυτό:
+        - χρησιμοποιείται από όλες τις σκηνές
+        - είναι ανεξάρτητο από το pygame
+        """
+
+        # ---------------------------------------------
+        # Μεταβλητές για εισαγωγή κειμένου (π.χ. ονόματα)
+        # ---------------------------------------------
+        text = ""          # χαρακτήρες που πληκτρολογήθηκαν στο frame
+        backspace = False  # αν πατήθηκε backspace στο frame
+
+        # ---------------------------------------------
+        # Επεξεργασία pygame events
+        # ---------------------------------------------
+        # Εδώ ΔΕΝ χειριζόμαστε κίνηση.
+        # Χρησιμοποιούμε events μόνο όπου χρειάζεται στιγμιακή πληροφορία.
+        for event in pygame.event.get():
+
+            # Αν ο χρήστης κλείσει το παράθυρο
+            if event.type == pygame.QUIT:
+                pygame.quit()
+                raise SystemExit
+
+            # Εισαγωγή χαρακτήρων (unicode-safe)
+            # Χρησιμοποιείται κυρίως σε input πεδία (π.χ. High Scores)
+            if event.type == pygame.TEXTINPUT:
+                text += event.text
+
+            # Αν πατήθηκε backspace
+            # Δεν χρησιμοποιούμε key.get_pressed εδώ,
+            # γιατί μας ενδιαφέρει το στιγμιαίο πάτημα
+            if event.type == pygame.KEYDOWN:
+                if event.key == pygame.K_BACKSPACE:
+                    backspace = True
+
+        # ---------------------------------------------
+        # Polling κατάστασης πληκτρολογίου
+        # ---------------------------------------------
+        # pygame.key.get_pressed επιστρέφει την τρέχουσα
+        # κατάσταση όλων των πλήκτρων
+        keys = pygame.key.get_pressed()
+
+        # ---------------------------------------------
+        # Δημιουργία και επιστροφή InputSnapshot
+        # ---------------------------------------------
+        return InputSnapshot(
+            up=keys[pygame.K_UP],        # κίνηση προς τα πάνω
+            down=keys[pygame.K_DOWN],    # κίνηση προς τα κάτω
+            left=keys[pygame.K_LEFT],    # κίνηση αριστερά
+            right=keys[pygame.K_RIGHT],  # κίνηση δεξιά
+            fire=keys[pygame.K_SPACE],   # γενική χρήση: confirm / shoot
+            pause=keys[pygame.K_ESCAPE], # pause ή επιστροφή
+            backspace=backspace,         # διαγραφή χαρακτήρα
+            text=text,                   # κείμενο που πληκτρολογήθηκε
+        )
Index: shared/ai/enemy_brain.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/ai/enemy_brain.py b/shared/ai/enemy_brain.py
--- a/shared/ai/enemy_brain.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/ai/enemy_brain.py	(date 1767632578577)
@@ -1,0 +1,140 @@
+from collections import deque
+from shared.model.types import Direction, TileType, MonsterForm, GameMode
+
+
+# Λεξικό που μετατρέπει μια κατεύθυνση σε μεταβολή συντεταγμένων (dx, dy)
+# Χρησιμοποιείται τόσο για αναζήτηση όσο και για τελική κίνηση
+DIRS = {
+    Direction.UP: (0, -1),
+    Direction.DOWN: (0, 1),
+    Direction.LEFT: (-1, 0),
+    Direction.RIGHT: (1, 0),
+}
+
+
+class EnemyBrain:
+    """
+    Σύστημα τεχνητής νοημοσύνης (AI) των εχθρών.
+
+    Υλοποιεί λογική απόφασης κατεύθυνσης κίνησης
+    χρησιμοποιώντας αναζήτηση διαδρομής (BFS) σε πλέγμα.
+
+    Η συμπεριφορά εξαρτάται από:
+    - τη μορφή του εχθρού (Nobbin / Hobbin)
+    - την κατάσταση του παιχνιδιού (Normal / Bonus)
+    """
+
+    def decide(self, enemy, player, level, game_mode):
+        """
+        Αποφασίζει προς ποια κατεύθυνση θα κινηθεί ο εχθρός στο επόμενο βήμα.
+
+        Επιστρέφει:
+        - Direction (UP, DOWN, LEFT, RIGHT)
+        - ή None αν δεν υπάρχει έγκυρη κίνηση
+        """
+
+        # Αρχική θέση εχθρού
+        start = (enemy.tile_x, enemy.tile_y)
+
+        # =========================
+        # BONUS MODE — FLEE LOGIC
+        # =========================
+        # Αν το παιχνίδι βρίσκεται σε BONUS mode,
+        # ο εχθρός προσπαθεί να απομακρυνθεί από τον παίκτη
+        if game_mode == GameMode.BONUS:
+            # Υπολογισμός διανύσματος από τον παίκτη προς τον εχθρό
+            dx = enemy.tile_x - player.tile_x
+            dy = enemy.tile_y - player.tile_y
+
+            # Στόχος: ένα tile προς την αντίθετη κατεύθυνση
+            goal = (enemy.tile_x + dx, enemy.tile_y + dy)
+        else:
+            # Κανονικό mode: στόχος είναι η θέση του παίκτη
+            goal = (player.tile_x, player.tile_y)
+
+        # =========================
+        # BFS ΑΝΑΖΗΤΗΣΗ ΔΙΑΔΡΟΜΗΣ
+        # =========================
+
+        # Ουρά BFS (First In – First Out)
+        queue = deque([start])
+
+        # Λεξικό που κρατά από ποιο tile ήρθαμε σε κάθε tile
+        # Χρησιμοποιείται για ανακατασκευή της διαδρομής
+        came_from = {start: None}
+
+        # Όσο υπάρχουν κόμβοι προς εξερεύνηση
+        while queue:
+            cx, cy = queue.popleft()
+
+            # Αν φτάσαμε στο στόχο, σταματάμε
+            if (cx, cy) == goal:
+                break
+
+            # Εξερεύνηση γειτονικών tiles
+            for direction, (dx, dy) in DIRS.items():
+                nx, ny = cx + dx, cy + dy
+
+                # Έλεγχος ορίων πίστας
+                if not level.in_bounds(nx, ny):
+                    continue
+
+                # Τύπος πλακιδίου
+                tile = level.get_tile(nx, ny)
+
+                # =========================
+                # ΚΑΝΟΝΕΣ ΚΙΝΗΣΗΣ ΑΝΑ ΜΟΡΦΗ
+                # =========================
+
+                # Nobbin: κινείται ΜΟΝΟ σε tunnels
+                if enemy.form == MonsterForm.NOBBIN:
+                    if tile != TileType.TUNNEL:
+                        continue
+
+                # Hobbin: μπορεί να σκάβει
+                elif enemy.form == MonsterForm.HOBBIN:
+                    if tile not in (
+                        TileType.TUNNEL,
+                        TileType.DIRT,
+                        TileType.EMERALD,
+                    ):
+                        continue
+
+                # Αν το tile δεν έχει επισκεφθεί ακόμα
+                if (nx, ny) not in came_from:
+                    # Καταγράφουμε από πού ήρθαμε
+                    came_from[(nx, ny)] = (cx, cy)
+                    queue.append((nx, ny))
+
+        # =========================
+        # ΑΝ ΔΕΝ ΒΡΕΘΗΚΕ ΔΙΑΔΡΟΜΗ
+        # =========================
+        if goal not in came_from:
+            return None
+
+        # =========================
+        # ΑΝΑΚΑΤΑΣΚΕΥΗ ΠΡΩΤΟΥ ΒΗΜΑΤΟΣ
+        # =========================
+
+        # Ξεκινάμε από τον στόχο
+        cur = goal
+
+        # Πηγαίνουμε πίσω μέχρι το tile που είναι ακριβώς δίπλα στον εχθρό
+        while came_from[cur] != start:
+            cur = came_from[cur]
+
+            # Ασφαλιστική δικλείδα
+            if cur is None:
+                return None
+
+        # Υπολογισμός διαφοράς θέσης
+        dx = cur[0] - enemy.tile_x
+        dy = cur[1] - enemy.tile_y
+
+        # Μετατροπή διαφοράς σε Direction
+        for direction, (vx, vy) in DIRS.items():
+            if (vx, vy) == (dx, dy):
+                return direction
+
+        # Αν κάτι πήγε στραβά
+        return None
Index: shared/input/input_snapshot.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/input/input_snapshot.py b/shared/input/input_snapshot.py
--- a/shared/input/input_snapshot.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/input/input_snapshot.py	(date 1767632370465)
@@ -1,0 +1,41 @@
+class InputSnapshot:
+    """
+    Κλάση στιγμιότυπου εισόδου (input snapshot) για ένα frame του παιχνιδιού.
+
+    Δημιουργείται από το σύστημα εισόδου (InputController)
+    και μεταφέρεται αυτούσιο στις σκηνές (Scenes).
+
+    Ονομάζεται "snapshot" γιατί:
+    - περιγράφει την κατάσταση των πλήκτρων σε ΜΙΑ συγκεκριμένη χρονική στιγμή
+    - δεν αλλάζει κατά τη διάρκεια του frame
+    - αποτρέπει απευθείας χρήση pygame.key.get_pressed() μέσα στις σκηνές
+    """
+
+    def __init__(self):
+        # Κίνηση προς τα πάνω
+        # Αντιστοιχεί συνήθως στο πλήκτρο UP
+        self.up = False
+
+        # Κίνηση προς τα κάτω
+        # Αντιστοιχεί συνήθως στο πλήκτρο DOWN
+        self.down = False
+
+        # Κίνηση προς τα αριστερά
+        # Αντιστοιχεί συνήθως στο πλήκτρο LEFT
+        self.left = False
+
+        # Κίνηση προς τα δεξιά
+        # Αντιστοιχεί συνήθως στο πλήκτρο RIGHT
+        self.right = False
+
+        # Πλήκτρο παύσης / επιστροφής
+        # Χρησιμοποιείται για:
+        # - pause menu
+        # - επιστροφή στο main menu
+        # - έξοδο από υπο-σκηνές (π.χ. How To Play)
+        self.pause = False
+
+        # Πυροβολισμός όπλου
+        # Συνήθως αντιστοιχεί στο πλήκτρο SPACE
+        # Χρησιμοποιείται από το WeaponSystem
+        self.fire = False
Index: client/app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/app.py b/client/app.py
--- a/client/app.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/app.py	(date 1767632680694)
@@ -1,0 +1,188 @@
+import pygame
+import os
+
+# --------------------------------------------------
+# Ρυθμίσεις παιχνιδιού (ανάλυση, fps, τίτλος)
+# --------------------------------------------------
+from shared.config.game_config import GameConfig
+
+# --------------------------------------------------
+# Διαχείριση σκηνών (SceneManager)
+# --------------------------------------------------
+from shared.core.scene import SceneManager
+
+# --------------------------------------------------
+# Σύστημα εισόδου (πληκτρολόγιο)
+# --------------------------------------------------
+from client.controllers.input_controller import InputController
+
+# --------------------------------------------------
+# Σκηνές του παιχνιδιού
+# --------------------------------------------------
+from client.views.scenes.main_menu_scene import MainMenuScene
+from client.views.scenes.game_scene import GameScene
+from client.views.scenes.highscores_scene import HighScoresScene
+from client.views.scenes.settings_scene import SettingsScene
+from client.views.scenes.gameover_scene import GameOverScene
+from client.views.scenes.how_to_play_scene import HowToPlayScene
+
+# --------------------------------------------------
+# Διαχείριση ήχου και μουσικής
+# --------------------------------------------------
+from shared.services.audio_manager import AudioManager
+
+
+class GameApp:
+    """
+    Κεντρική κλάση της εφαρμογής.
+
+    Είναι υπεύθυνη για:
+    - αρχικοποίηση pygame
+    - φόρτωση ήχου
+    - δημιουργία παραθύρου
+    - διαχείριση σκηνών
+    - εκτέλεση του κύριου game loop
+    """
+
+    def __init__(self) -> None:
+        # --------------------------------------------------
+        # Φόρτωση default ρυθμίσεων παιχνιδιού
+        # --------------------------------------------------
+        self.config = GameConfig.default()
+
+        # --------------------------------------------------
+        # Προ-αρχικοποίηση audio mixer
+        # Γίνεται ΠΡΙΝ το pygame.init για καθαρό ήχο
+        # --------------------------------------------------
+        pygame.mixer.pre_init(
+            frequency=44100,   # ποιότητα CD
+            size=-16,          # 16-bit signed
+            channels=2,        # stereo
+            buffer=512         # μικρό buffer για χαμηλό latency
+        )
+
+        # --------------------------------------------------
+        # Αρχικοποίηση pygame
+        # --------------------------------------------------
+        pygame.init()
+        # pygame.mixer.init()  # δεν χρειάζεται, γίνεται μέσω AudioManager
+
+        # --------------------------------------------------
+        # Δημιουργία παραθύρου παιχνιδιού
+        # --------------------------------------------------
+        pygame.display.set_caption(self.config.title)
+        self.screen = pygame.display.set_mode(
+            (self.config.screen_width, self.config.screen_height)
+        )
+
+        # Ρολόι για υπολογισμό delta time (dt)
+        self.clock = pygame.time.Clock()
+
+        # --------------------------------------------------
+        # Αρχικοποίηση AudioManager
+        # --------------------------------------------------
+        AudioManager.init()
+
+        # Φάκελος ήχων (κάτω από client/assets/audio)
+        assets_dir = os.path.join(
+            os.path.dirname(__file__), "assets", "audio"
+        )
+
+        # Φόρτωση ηχητικών εφέ
+        AudioManager.load_sounds(assets_dir)
+
+        # Φόρτωση και αναπαραγωγή μουσικής μενού
+        menu_music = os.path.join(assets_dir, "menu_melody.ogg")
+        AudioManager.play_music(menu_music, loop=True)
+        AudioManager.set_music_volume(0.12)
+
+        # --------------------------------------------------
+        # CORE ΣΥΣΤΗΜΑΤΑ
+        # --------------------------------------------------
+        self.input_controller = InputController()
+        self.scene_manager = SceneManager()
+        self._running = True
+
+        # --------------------------------------------------
+        # Καταχώρηση όλων των σκηνών
+        # --------------------------------------------------
+        self.scene_manager.register_scene(
+            "menu",
+            MainMenuScene(self.scene_manager, quit_callback=self.stop)
+        )
+
+        self.scene_manager.register_scene(
+            "game",
+            GameScene(self.scene_manager)
+        )
+
+        self.scene_manager.register_scene(
+            "howto",
+            HowToPlayScene(self.scene_manager)
+        )
+
+        self.scene_manager.register_scene(
+            "highscores",
+            HighScoresScene(self.scene_manager)
+        )
+
+        self.scene_manager.register_scene(
+            "settings",
+            SettingsScene(self.scene_manager)
+        )
+
+        self.scene_manager.register_scene(
+            "gameover",
+            GameOverScene(self.scene_manager)
+        )
+
+        # --------------------------------------------------
+        # Εκκίνηση από το κεντρικό μενού
+        # --------------------------------------------------
+        self.scene_manager.set_scene("menu", {})
+
+    # ==================================================
+    # Τερματισμός εφαρμογής
+    # ==================================================
+    def stop(self) -> None:
+        """
+        Σταματά τον κύριο βρόχο του παιχνιδιού.
+        Καλείται όταν ο χρήστης επιλέξει Quit ή κλείσει το παράθυρο.
+        """
+        self._running = False
+
+    # ==================================================
+    # Κύριος βρόχος παιχνιδιού (Game Loop)
+    # ==================================================
+    def run(self) -> None:
+        """
+        Ο βασικός game loop.
+
+        Εκτελείται συνεχώς μέχρι το _running να γίνει False.
+        """
+        while self._running:
+            # Υπολογισμός delta time σε δευτερόλεπτα
+            dt = self.clock.tick(self.config.fps) / 1000.0
+
+            # --------------------------------------------------
+            # Διαχείριση events (π.χ. κλείσιμο παραθύρου)
+            # --------------------------------------------------
+            for event in pygame.event.get():
+                if event.type == pygame.QUIT:
+                    self.stop()
+
+            # --------------------------------------------------
+            # Ανάγνωση input και ενημέρωση σκηνής
+            # --------------------------------------------------
+            snapshot = self.input_controller.capture()
+            self.scene_manager.handle_input(snapshot)
+            self.scene_manager.update(dt)
+            self.scene_manager.render(self.screen)
+
+            # Ενημέρωση οθόνης
+            pygame.display.flip()
+
+        # --------------------------------------------------
+        # Καθαρός τερματισμός pygame
+        # --------------------------------------------------
+        pygame.quit()
Index: client/views/scenes/game_scene.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/scenes/game_scene.py b/client/views/scenes/game_scene.py
--- a/client/views/scenes/game_scene.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/scenes/game_scene.py	(date 1767634836473)
@@ -1,0 +1,1679 @@
+# ------------------------------------------------------------
+# Βασικές βιβλιοθήκες
+# ------------------------------------------------------------
+
+# pygame: βιβλιοθήκη για γραφικά, input, χρόνο (dt), surfaces,
+# sprites και γενικά όλο το game loop
+import pygame
+
+# random: χρησιμοποιείται για τυχαίες επιλογές μέσα στο παιχνίδι,
+# π.χ. spawn εχθρών ή τυχαία συμπεριφορά AI
+import random
+
+
+# ------------------------------------------------------------
+# Core αρχιτεκτονική σκηνών
+# ------------------------------------------------------------
+
+# Η Scene είναι αφηρημένη κλάση (abstract base class)
+# Όλες οι σκηνές του παιχνιδιού (menu, game, game over κ.λπ.)
+# κληρονομούν από αυτή και είναι υποχρεωμένες να υλοποιούν
+# τις μεθόδους enter, exit, handle_input, update και render
+from shared.core.scene import Scene
+
+
+# ------------------------------------------------------------
+# MODEL layer – αντικείμενα παιχνιδιού (καθαρά δεδομένα)
+# ------------------------------------------------------------
+
+# Level:
+# Αναπαριστά την πίστα του παιχνιδιού ως grid (tiles).
+# Περιέχει πληροφορίες για:
+# - πλάτος / ύψος
+# - τύπο κάθε tile (DIRT, TUNNEL, EMERALD κ.λπ.)
+# - έλεγχο ορίων (in_bounds)
+from shared.model.level import Level
+
+# Player:
+# Αναπαριστά τον παίκτη.
+# Κρατά:
+# - tile_x, tile_y (θέση στο grid)
+# - direction (προς τα πού κοιτάει)
+# - alive (αν είναι ζωντανός)
+from shared.model.player import Player
+
+# Enemy:
+# Αναπαριστά έναν εχθρό.
+# Κληρονομεί από Entity και περιέχει:
+# - μορφή (NOBBIN ή HOBBIN)
+# - timers για αλλαγή μορφής και κίνηση
+# - alive flag
+from shared.model.enemy import Enemy
+
+# GoldBag:
+# Αναπαριστά έναν σάκο χρυσού.
+# Μπορεί να:
+# - πέσει (falling)
+# - σπάσει και να γίνει gold pile
+# - συλλεχθεί
+from shared.model.gold_bag import GoldBag
+
+# Score:
+# Διαχειρίζεται το σκορ του παίκτη.
+# Υποστηρίζει:
+# - απλή προσθήκη πόντων
+# - combo από emeralds
+# - bonus από φαγωμένους εχθρούς
+from shared.model.score import Score
+
+# Lives:
+# Διαχειρίζεται τις ζωές του παίκτη.
+# Περιέχει:
+# - αριθμό ζωών
+# - λογική extra life κάθε X πόντους
+from shared.model.lives import Lives
+
+# Weapon:
+# Διαχειρίζεται το όπλο του παίκτη.
+# Περιέχει:
+# - cooldown
+# - timer για το πότε μπορεί να ξαναπυροβολήσει
+from shared.model.weapon import Weapon
+
+# Types / Enums:
+# Direction  : κατεύθυνση κίνησης
+# TileType   : τύπος πλακιδίου πίστας
+# GameMode  : κατάσταση παιχνιδιού (NORMAL, BONUS, LEVEL_COMPLETE)
+from shared.model.types import Direction, TileType, GameMode
+
+
+# ------------------------------------------------------------
+# SYSTEMS – λογική παιχνιδιού (gameplay rules)
+# ------------------------------------------------------------
+
+# GridMovementSystem:
+# Υλοποιεί την κίνηση entity στο grid (πάνω/κάτω/αριστερά/δεξιά)
+from shared.services.grid_movement import GridMovementSystem
+
+# TileInteractionSystem:
+# Χειρίζεται αλληλεπίδραση entity με tiles
+# π.χ. σκάψιμο χώματος
+from shared.services.tile_interaction import TileInteractionSystem
+
+# EnemyAISystem:
+# Συνδέει τον EnemyBrain με το movement system
+# και αποφασίζει πώς κινούνται οι εχθροί
+from shared.services.enemy_ai_system import EnemyAISystem
+
+# EnemyFormSystem:
+# Διαχειρίζεται την αλλαγή μορφής εχθρού
+# (NOBBIN <-> HOBBIN)
+from shared.services.enemy_form_system import EnemyFormSystem
+
+# HobbinDiggingSystem:
+# Επιτρέπει στους Hobbin να σκάβουν χώμα και emeralds
+from shared.services.hobbin_digging_system import HobbinDiggingSystem
+
+# GoldBagSystem:
+# Διαχειρίζεται πτώση σακιών χρυσού και μετατροπή τους σε gold
+from shared.services.gold_bag_system import GoldBagSystem
+
+# GoldBagPushSystem:
+# Διαχειρίζεται το σπρώξιμο σακιών χρυσού αριστερά / δεξιά
+from shared.services.gold_bag_push_system import GoldBagPushSystem
+
+# ScoreSystem:
+# Συνδέει το score με το gameplay
+# π.χ. συλλογή emeralds
+from shared.services.score_system import ScoreSystem
+
+# WeaponSystem:
+# Διαχειρίζεται το firing του όπλου
+# (δημιουργία bullets, cooldown)
+from shared.services.weapon_system import WeaponSystem
+
+# BulletSystem:
+# Διαχειρίζεται την κίνηση bullets και συγκρούσεις με εχθρούς
+from shared.services.bullet_system import BulletSystem
+
+# EnemySpawner:
+# Δημιουργεί νέους εχθρούς σε συγκεκριμένα spawn points
+from shared.services.enemy_spawner import EnemySpawner
+
+# DifficultyScaler:
+# Ορίζει τη δυσκολία ανά πίστα
+# (αριθμός enemies, emeralds, ταχύτητα κ.λπ.)
+from shared.services.difficulty_scaler import DifficultyScaler
+
+
+# ------------------------------------------------------------
+# AI
+# ------------------------------------------------------------
+
+# EnemyBrain:
+# Υλοποιεί την τεχνητή νοημοσύνη εχθρών
+# (εύρεση διαδρομής προς τον παίκτη ή φυγή σε bonus mode)
+from shared.ai.enemy_brain import EnemyBrain
+
+
+# ------------------------------------------------------------
+# VIEW layer – κάμερα και γραφικά
+# ------------------------------------------------------------
+
+# Camera2D:
+# Μετατρέπει συντεταγμένες κόσμου (tiles) σε συντεταγμένες οθόνης
+from client.views.camera import Camera2D
+
+# TilemapView:
+# Ζωγραφίζει την πίστα (χώμα, tunnels, background)
+from client.views.tilemap_view import TilemapView
+
+
+# ------------------------------------------------------------
+# SPRITES – οπτική αναπαράσταση αντικειμένων
+# ------------------------------------------------------------
+
+# PlayerSprite:
+# Ζωγραφίζει τον παίκτη με σωστή κατεύθυνση
+from client.views.sprites.player_sprite import PlayerSprite
+
+# EmeraldSprite:
+# Ζωγραφίζει τα emeralds
+from client.views.sprites.emerald_sprite import EmeraldSprite
+
+# GoldBagSprite:
+# Ζωγραφίζει σάκους χρυσού / πτώση / gold pile
+from client.views.sprites.gold_bag_sprite import GoldBagSprite
+
+# EnemySprite:
+# Ζωγραφίζει Nobbin / Hobbin με σωστή κατεύθυνση
+from client.views.sprites.enemy_sprite import EnemySprite
+
+
+# ------------------------------------------------------------
+# EFFECTS
+# ------------------------------------------------------------
+
+# ExplosionSystem:
+# Υλοποιεί απλά particle effects εκρήξεων
+from client.views.effects.explosion import ExplosionSystem
+
+
+# ------------------------------------------------------------
+# AUDIO
+# ------------------------------------------------------------
+
+# AudioManager:
+# Διαχειρίζεται μουσική και ηχητικά εφέ
+from shared.services.audio_manager import AudioManager
+
+
+
+class GameScene(Scene):
+    # ==================================================
+    # ΣΤΑΘΕΡΕΣ (CONSTANTS) ΤΗΣ ΣΚΗΝΗΣ
+    # ==================================================
+
+    # Μέγεθος ενός tile σε pixels (32x32)
+    TILE_SIZE = 32
+
+    # Χρόνος (σε δευτερόλεπτα) που ο παίκτης είναι άτρωτος
+    # μετά από respawn
+    INVULN_SECONDS = 0.70
+
+    # Αρχική θέση respawn του παίκτη στο grid
+    RESPAWN_X = 5
+    RESPAWN_Y = 5
+
+    # Καθυστέρηση πριν περάσουμε στο επόμενο level
+    # αφού καθαριστεί η πίστα
+    LEVEL_COMPLETE_DELAY = 2.0
+
+
+    # ==================================================
+    # ΑΡΧΙΚΟΠΟΙΗΣΗ ΣΚΗΝΗΣ
+    # ==================================================
+    def __init__(self, scene_manager):
+        # Αναφορά στο SceneManager
+        # Χρησιμοποιείται για αλλαγή σκηνών (π.χ. game → game over)
+        self.sm = scene_manager
+
+
+        # ==================================================
+        # LEVEL & PLAYER
+        # ==================================================
+
+        # Τρέχον επίπεδο παιχνιδιού (ξεκινάμε από το 1)
+        self.level_index = 1
+
+        # Δημιουργία του Level αντικειμένου
+        # Κλάση: Level
+        # Αναπαριστά την πίστα ως grid 60x40 tiles
+        self.level = Level(60, 40)
+
+        # Δημιουργία του Player 1
+        # Κλάση: Player
+        # Τοποθετείται στη θέση respawn
+        self.player = Player("p1", self.RESPAWN_X, self.RESPAWN_Y)
+
+        # Timer άτρωτου παίκτη (invulnerability)
+        # Μηδενίζεται αρχικά
+        self._invuln_timer = 0.0
+
+        # Λίστα παικτών (προετοιμασία για multiplayer)
+        # Προς το παρόν περιέχει μόνο τον Player 1
+        self.players = [self.player]
+
+
+        # ==================================================
+        # GAME STATE
+        # ==================================================
+
+        # Κατάσταση παιχνιδιού
+        # NORMAL / BONUS / LEVEL_COMPLETE
+        self.game_mode = GameMode.NORMAL
+
+        # Timer που μετράει πόσο έχουμε μείνει
+        # στο LEVEL_COMPLETE state
+        self.level_complete_timer = 0.0
+
+
+        # ==================================================
+        # DIFFICULTY SYSTEM
+        # ==================================================
+
+        # Δημιουργία DifficultyScaler
+        # Κλάση: DifficultyScaler
+        # Όλη η λογική δυσκολίας βρίσκεται εκεί
+        self.scaler = DifficultyScaler()
+
+        # Συνολικός αριθμός εχθρών για το level
+        self.total_enemies = self.scaler.enemies_for_level(self.level_index)
+
+        # Μέγιστοι ταυτόχρονοι εχθροί στην πίστα
+        # (αρχικά περιορισμένοι για ομαλή δυσκολία)
+        self.max_active = min(2, self.total_enemies)
+
+        # Καθυστέρηση κίνησης εχθρών
+        # Όσο μικρότερη, τόσο πιο γρήγοροι
+        self.enemy_delay = self.scaler.enemy_move_delay(self.level_index)
+
+
+        # ==================================================
+        # ENEMY MANAGEMENT
+        # ==================================================
+
+        # Δημιουργία EnemySpawner
+        # Κλάση: EnemySpawner
+        # Καθορίζει από πού εμφανίζονται οι εχθροί
+        self.enemy_spawner = EnemySpawner(
+            spawn_x=self.level.width - 2,
+            spawn_y=2
+        )
+
+        # Λίστα ενεργών εχθρών στην πίστα
+        self.enemies: list[Enemy] = []
+
+        # Πόσοι εχθροί έχουν γίνει spawn συνολικά
+        self.spawned_total = 0
+
+        # Timer για spawn νέων εχθρών
+        self._spawn_timer = 0.0
+
+        # Καθυστέρηση ανάμεσα σε spawns
+        self.spawn_delay = 0.8
+
+
+        # ==================================================
+        # GOLD BAGS
+        # ==================================================
+
+        # Λίστα σακιών χρυσού
+        # Δημιουργούνται δυναμικά αργότερα
+        self.gold_bags = []
+
+
+        # ==================================================
+        # SYSTEMS (ΛΟΓΙΚΗ ΠΑΙΧΝΙΔΙΟΥ)
+        # ==================================================
+
+        # Σύστημα κίνησης σε grid
+        self.movement = GridMovementSystem()
+
+        # Σύστημα αλληλεπίδρασης με tiles (σκάψιμο κ.λπ.)
+        self.tile_interaction = TileInteractionSystem()
+
+        # Enemy AI
+        # EnemyBrain: αποφασίζει κατεύθυνση
+        # EnemyAISystem: εφαρμόζει την απόφαση
+        self.enemy_brain = EnemyBrain()
+        self.enemy_ai = EnemyAISystem(self.enemy_brain)
+
+        # Σύστημα αλλαγής μορφής εχθρού (Nobbin ↔ Hobbin)
+        self.enemy_form_system = EnemyFormSystem()
+
+        # Σύστημα σκαψίματος Hobbin
+        self.hobbin_digging = HobbinDiggingSystem()
+
+        # Σύστημα πτώσης σακιών χρυσού
+        self.gold_bag_system = GoldBagSystem()
+
+        # Σύστημα σπρωξίματος σακιών χρυσού
+        self.gold_bag_push = GoldBagPushSystem()
+
+
+        # ==================================================
+        # SCORE & LIVES
+        # ==================================================
+
+        # Score Player 1
+        self.score = Score()
+
+        # Σύστημα που συνδέει gameplay με score
+        self.score_system = ScoreSystem(self.score)
+
+        # Ζωές Player 1
+        self.lives = Lives(start_lives=3)
+
+        # Player 2 (έτοιμο αλλά ανενεργό)
+        self.score_p2 = Score()
+        self.lives_p2 = Lives(start_lives=3)
+
+
+        # ==================================================
+        # WEAPON & BULLETS
+        # ==================================================
+
+        # Όπλο παίκτη με cooldown
+        self.weapon = Weapon(cooldown=2.0)
+
+        # Σύστημα χρήσης όπλου
+        self.weapon_system = WeaponSystem()
+
+        # Σύστημα bullets (κίνηση, συγκρούσεις)
+        self.bullet_system = BulletSystem()
+
+        # Λίστα ενεργών bullets
+        self.bullets = []
+
+
+        # ==================================================
+        # VIEW (ΚΑΜΕΡΑ & ΓΡΑΦΙΚΑ)
+        # ==================================================
+
+        # Legacy camera (κρατιέται για παλιό κώδικα)
+        self.camera = None
+
+        # Κάμερα Player 1
+        self.camera_p1 = None
+
+        # Κάμερα Player 2 (split screen)
+        self.camera_p2 = None
+
+        # View της πίστας
+        self.tilemap_view = TilemapView(self.TILE_SIZE)
+
+        # Font HUD (θα φορτωθεί στο enter)
+        self._font = None
+
+
+        # ==================================================
+        # TIMING & INPUT
+        # ==================================================
+
+        # Cooldown κίνησης παίκτη (grid-based)
+        self._move_cooldown = 0.0
+
+        # Τελευταίο InputSnapshot
+        self._last_input = None
+
+
+        # ==================================================
+        # SPRITES
+        # ==================================================
+
+        # Sprite παίκτη
+        self.player_sprite = PlayerSprite()
+
+        # Sprite emerald
+        self.emerald_sprite = EmeraldSprite()
+
+        # Sprite gold bag
+        self.gold_bag_sprite = GoldBagSprite()
+
+        # Sprite εχθρών
+        self.enemy_sprite = EnemySprite()
+
+
+        # ==================================================
+        # EFFECTS
+        # ==================================================
+
+        # Σύστημα εκρήξεων (particles)
+        self.explosions = ExplosionSystem(self.TILE_SIZE)
+
+        # Αποθήκευση προηγούμενων ζωντανών εχθρών
+        # Χρησιμοποιείται για detection θανάτων
+        self._alive_enemy_ids_prev = set()
+
+
+        # ==================================================
+        # PLAYERS (MULTI-READY)
+        # ==================================================
+
+        # Player 1 (υπάρχων)
+        self.player1 = self.player
+
+        # Player 2 (θα δημιουργηθεί αν επιλεγεί multiplayer)
+        self.player2 = None
+
+        # Λίστα παικτών (ξεκινά με τον Player 1)
+        self.players = [self.player1]
+
+
+    # ==================================================
+    # Scene interface
+    # ==================================================
+
+    def enter(self, payload=None):
+        # --------------------------------------------------
+        # Φόρτωση γραμματοσειράς HUD
+        # --------------------------------------------------
+        # Γίνεται μόνο την πρώτη φορά που μπαίνουμε στη σκηνή
+        # ώστε να μη φορτώνεται ξανά άσκοπα
+        if self._font is None:
+            self._font = pygame.font.Font(
+                "assets/fonts/Orbitron-Bold.ttf", 18
+            )
+
+        # --------------------------------------------------
+        # Πλήθος παικτών
+        # --------------------------------------------------
+        # Αν το payload υπάρχει, διαβάζουμε πόσοι παίκτες επιλέχθηκαν
+        # από το Main Menu
+        # Αν όχι, default = 1 παίκτης
+        self.player_count = payload.get("players", 1) if payload else 1
+
+        # ==================================================
+        # HARD RESET – ΚΑΘΕ ΝΕΟ GAME (SINGLE ή MULTI)
+        # ==================================================
+        # Ό,τι ακολουθεί επαναφέρει το παιχνίδι στην αρχική
+        # κατάσταση, σαν να άνοιξε μόλις το παιχνίδι.
+
+        # --------------------------------------------------
+        # Reset Level
+        # --------------------------------------------------
+        # Επαναφορά στο πρώτο επίπεδο
+        self.level_index = 1
+
+        # Δημιουργία ΝΕΟΥ αντικειμένου Level
+        # Κλάση: Level
+        # Η παλιά πίστα πετιέται και ξεκινάμε από καθαρό grid
+        self.level = Level(60, 40)
+
+        # --------------------------------------------------
+        # Reset Difficulty
+        # --------------------------------------------------
+        # Δημιουργία νέου DifficultyScaler
+        self.scaler = DifficultyScaler()
+
+        # Υπολογισμός συνολικών εχθρών για το level 1
+        self.total_enemies = self.scaler.enemies_for_level(self.level_index)
+
+        # Μέγιστοι ενεργοί εχθροί στην πίστα
+        self.max_active = min(2, self.total_enemies)
+
+        # Καθυστέρηση κίνησης εχθρών
+        self.enemy_delay = self.scaler.enemy_move_delay(self.level_index)
+
+        # ==================================================
+        # Players
+        # ==================================================
+
+        # --------------------------------------------------
+        # Player 1 (υπάρχει ΠΑΝΤΑ)
+        # --------------------------------------------------
+        # Επαναφορά κατάστασης
+        self.player.alive = True
+
+        # Τοποθέτηση στο σημείο respawn
+        self.player.tile_x = self.RESPAWN_X
+        self.player.tile_y = self.RESPAWN_Y
+
+        # Μηδενισμός κατεύθυνσης (ώστε να μην πυροβολεί άμεσα)
+        self.player.direction = None
+
+        # --------------------------------------------------
+        # Player 2 (μόνο αν επιλεγεί multiplayer)
+        # --------------------------------------------------
+        if self.player_count == 2:
+
+            # Αν δεν υπάρχει ήδη Player 2, τον δημιουργούμε
+            if self.player2 is None:
+                self.player2 = Player(
+                    "p2",
+                    self.RESPAWN_X + 2,
+                    self.RESPAWN_Y
+                )
+
+            # Reset κατάστασης Player 2
+            self.player2.alive = True
+            self.player2.tile_x = self.RESPAWN_X + 2
+            self.player2.tile_y = self.RESPAWN_Y
+            self.player2.direction = None
+
+            # Λίστα ενεργών παικτών
+            self.players = [self.player, self.player2]
+
+        else:
+            # Single Player
+            # Ο Player 2 απενεργοποιείται πλήρως
+            self.player2 = None
+            self.players = [self.player]
+
+        # ==================================================
+        # Cameras
+        # ==================================================
+
+        # Παίρνουμε το μέγεθος της οθόνης
+        screen = pygame.display.get_surface()
+        w, h = screen.get_size()
+
+        if self.player2:
+            # Split screen:
+            # Κάθε παίκτης έχει τη δική του κάμερα
+            self.camera_p1 = Camera2D(w // 2, h, self.TILE_SIZE)
+            self.camera_p2 = Camera2D(w // 2, h, self.TILE_SIZE)
+        else:
+            # Single player:
+            # Μία κάμερα για όλη την οθόνη
+            self.camera_p1 = Camera2D(w, h, self.TILE_SIZE)
+            self.camera_p2 = None
+
+        # Legacy camera
+        # Χρησιμοποιείται από παλιό κώδικα για ασφάλεια
+        self.camera = self.camera_p1
+
+        # --------------------------------------------------
+        # Reset προηγούμενων εχθρών (για explosion detection)
+        # --------------------------------------------------
+        self._alive_enemy_ids_prev = set()
+
+        # ==================================================
+        # Spawn περιεχομένου πίστας
+        # ==================================================
+        # ΠΡΟΣΟΧΗ:
+        # Γίνεται ΠΑΝΩ ΣΕ ΝΕΟ, ΚΑΘΑΡΟ Level
+
+        # Δημιουργία emeralds
+        self._spawn_emeralds()
+
+        # Δημιουργία gold bags
+        self._spawn_gold_bags()
+
+        # ==================================================
+        # Stats & Runtime State
+        # ==================================================
+
+        # Reset score
+        self.score.points = 0
+        self.score_p2.points = 0
+
+        # Reset ζωών
+        self.lives.count = 3
+        self.lives_p2.count = 3
+
+        # Καθαρισμός λιστών gameplay
+        self.enemies.clear()
+        self.bullets.clear()
+
+        # Reset spawn counters
+        self.spawned_total = 0
+        self._spawn_timer = 0.0
+
+        # Ενεργοποίηση άτρωτου μετά το respawn
+        self._invuln_timer = self.INVULN_SECONDS
+
+        # Reset κατάστασης παιχνιδιού
+        self.game_mode = GameMode.NORMAL
+        self.level_complete_timer = 0.0
+
+    def exit(self):
+        # Η μέθοδος exit() καλείται όταν η σκηνή GameScene
+        # εγκαταλείπεται (π.χ. πάμε σε Game Over ή Menu).
+        # Εδώ δεν απαιτείται καθαρισμός πόρων,
+        # γιατί το reset γίνεται στο enter().
+        pass
+
+
+    def handle_input(self, input_snapshot):
+        # Αποθηκεύουμε το στιγμιότυπο εισόδου (InputSnapshot)
+        # ώστε να χρησιμοποιηθεί στο update().
+        # Το InputSnapshot παράγεται από το InputController
+        # και περιέχει την κατάσταση πλήκτρων για ΑΥΤΟ το frame.
+        self._last_input = input_snapshot
+
+
+    # ==================================================
+    # Helpers (βοηθητικές μέθοδοι gameplay)
+    # ==================================================
+
+    def _respawn_player2(self):
+        # Επαναφορά Player 2 μετά από απώλεια ζωής
+
+        # Αν δεν υπάρχει Player 2 (single player),
+        # δεν κάνουμε τίποτα
+        if not self.player2:
+            return
+
+        # Τοποθέτηση Player 2 στο προκαθορισμένο respawn
+        self.player2.tile_x = self.RESPAWN_X + 2
+        self.player2.tile_y = self.RESPAWN_Y
+
+        # Μηδενισμός κατεύθυνσης
+        # ώστε να μην πυροβολήσει αμέσως
+        self.player2.direction = None
+
+
+    def _spawn_emeralds(self):
+        """
+        Δημιουργία emeralds στην πίστα.
+
+        Κανόνας παιχνιδιού:
+        - Level 1: 40 emeralds
+        - Κάθε επόμενο level: +10
+        """
+
+        # Υπολογισμός πλήθους emeralds
+        count = 40 + (self.level_index - 1) * 10
+
+        placed = 0          # πόσα emeralds έχουν τοποθετηθεί
+        attempts = 0        # πόσες προσπάθειες έγιναν
+        max_attempts = count * 10  # όριο για αποφυγή infinite loop
+
+        # Προσπαθούμε μέχρι να τοποθετηθούν όλα
+        # ή να ξεπεραστεί το όριο προσπαθειών
+        while placed < count and attempts < max_attempts:
+            attempts += 1
+
+            # Τυχαία θέση ΜΕΣΑ στα όρια της πίστας
+            x = random.randint(1, self.level.width - 2)
+            y = random.randint(1, self.level.height - 2)
+
+            # Emerald μπορεί να μπει ΜΟΝΟ πάνω σε DIRT
+            if self.level.get_tile(x, y) == TileType.DIRT:
+                self.level.set_tile(x, y, TileType.EMERALD)
+                placed += 1
+
+
+    def _spawn_gold_bags(self):
+        """
+        Δημιουργία gold bags (σάκοι χρυσού).
+
+        Κανόνας παιχνιδιού:
+        - Level 1: 5 σάκοι
+        - Κάθε επόμενο level: +2
+        """
+
+        # Υπολογισμός πλήθους σάκων
+        count = 5 + (self.level_index - 1) * 2
+
+        # Καθαρισμός παλιάς λίστας
+        self.gold_bags.clear()
+
+        placed = 0
+        attempts = 0
+        max_attempts = count * 15
+
+        while placed < count and attempts < max_attempts:
+            attempts += 1
+
+            # Επιλέγουμε θέση όχι κοντά στα άκρα
+            x = random.randint(2, self.level.width - 3)
+            y = random.randint(2, self.level.height - 3)
+
+            # Κανόνας:
+            # - το tile ΠΡΕΠΕΙ να είναι DIRT
+            # - από κάτω ΠΡΕΠΕΙ επίσης να είναι DIRT
+            #   (ώστε να μπορεί να πέσει αργότερα)
+            if (
+                self.level.get_tile(x, y) == TileType.DIRT
+                and self.level.get_tile(x, y + 1) == TileType.DIRT
+            ):
+                # Δημιουργία αντικειμένου GoldBag
+                # Κλάση: GoldBag
+                bag_id = f"g{placed}_{self.level_index}"
+                bag = GoldBag(bag_id, x, y)
+
+                # Προσθήκη στη λίστα gold bags
+                self.gold_bags.append(bag)
+
+                # Ενημέρωση tile map
+                self.level.set_tile(x, y, TileType.GOLD_BAG)
+
+                placed += 1
+
+
+    def _respawn_player(self):
+        # Επαναφορά Player 1 μετά από απώλεια ζωής
+
+        # Τοποθέτηση στο respawn
+        self.player.tile_x = self.RESPAWN_X
+        self.player.tile_y = self.RESPAWN_Y
+
+        # Μηδενισμός κατεύθυνσης
+        self.player.direction = None
+
+        # Καθαρισμός bullets
+        # (δεν συνεχίζουν να υπάρχουν μετά τον θάνατο)
+        self.bullets.clear()
+
+        # Ενεργοποίηση προσωρινής αθανασίας
+        self._invuln_timer = self.INVULN_SECONDS
+
+
+    def _handle_player_hit(self):
+        # Διαχείριση σύγκρουσης Player 1 με enemy
+
+        # Αν ο παίκτης είναι ακόμα άτρωτος,
+        # αγνοούμε το χτύπημα
+        if self._invuln_timer > 0.0:
+            return
+
+        # Χάνει μία ζωή
+        if not self.lives.lose_life():
+            # -----------------------------------------
+            # Player 1 ΠΕΘΑΝΕ ΟΡΙΣΤΙΚΑ
+            # -----------------------------------------
+            self.player.alive = False
+
+            # Αν υπάρχει Player 2 και έχει ζωές,
+            # το παιχνίδι συνεχίζεται σε co-op
+            if self.player2 and self.lives_p2.count > 0:
+                return
+
+            # Αλλιώς → Game Over
+            self.sm.set_scene(
+                "gameover",
+                {
+                    "score_p1": self.score.points,
+                    "score_p2": self.score_p2.points
+                }
+            )
+            return
+
+        # -----------------------------------------
+        # Player 1 έχει ακόμα ζωές → respawn
+        # -----------------------------------------
+        self._respawn_player()
+
+
+    def _load_next_level(self):
+        # --------------------------------------------------
+        # ΦΟΡΤΩΣΗ ΕΠΟΜΕΝΟΥ LEVEL
+        # --------------------------------------------------
+        # Η μέθοδος καλείται όταν:
+        # - έχουν συλλεχθεί ΟΛΑ τα emeralds
+        # - έχει ολοκληρωθεί το delay ολοκλήρωσης level
+        # --------------------------------------------------
+
+        # Έλεγχος αν υπάρχει επόμενο level
+        # Το DifficultyScaler γνωρίζει πόσα levels υποστηρίζονται
+        if not self.scaler.has_next_level(self.level_index):
+            # Δεν υπάρχει επόμενο level → ΤΕΛΟΣ ΠΑΙΧΝΙΔΙΟΥ
+            self.sm.set_scene(
+                "gameover",
+                {
+                    "score_p1": self.score.points,
+                    "score_p2": self.score_p2.points
+                }
+            )
+            return
+
+        # --------------------------------------------------
+        # Αύξηση δείκτη level & δημιουργία ΝΕΟΥ Level
+        # --------------------------------------------------
+        self.level_index += 1
+
+        # Δημιουργία νέου αντικειμένου Level
+        # Κλάση: Level (model)
+        self.level = Level(60, 40)
+
+        # --------------------------------------------------
+        # RESET Player 1
+        # --------------------------------------------------
+        # Ο Player είναι αντικείμενο της κλάσης Player
+        self.player.tile_x = self.RESPAWN_X
+        self.player.tile_y = self.RESPAWN_Y
+        self.player.direction = None
+
+        # ΣΗΜΑΝΤΙΚΟ:
+        # Αν ο Player είχε πεθάνει στο τέλος του προηγούμενου level,
+        # εδώ τον επαναφέρουμε ΖΩΝΤΑΝΟ
+        self.player.alive = True
+
+        # --------------------------------------------------
+        # RESET Player 2 (αν υπάρχει)
+        # --------------------------------------------------
+        if self.player2:
+            self.player2.tile_x = self.RESPAWN_X + 2
+            self.player2.tile_y = self.RESPAWN_Y
+            self.player2.direction = None
+
+            # Αντίστοιχα επαναφέρουμε τον Player 2
+            self.player2.alive = True
+
+        # --------------------------------------------------
+        # RESET runtime αντικειμένων
+        # --------------------------------------------------
+
+        # Καθαρισμός enemies (κλάση Enemy)
+        self.enemies.clear()
+
+        # Reset spawn counters
+        self.spawned_total = 0
+        self._spawn_timer = 0.0
+
+        # Καθαρισμός bullets (κλάση Bullet)
+        self.bullets.clear()
+
+        # Επιστροφή σε κανονικό game mode
+        self.game_mode = GameMode.NORMAL
+
+        # Reset timer ολοκλήρωσης level
+        self.level_complete_timer = 0.0
+
+        # --------------------------------------------------
+        # Difficulty scaling για νέο level
+        # --------------------------------------------------
+        self.total_enemies = self.scaler.enemies_for_level(self.level_index)
+
+        # Όσο ανεβαίνει το level:
+        # - αυξάνεται το max πλήθος ταυτόχρονων enemies
+        self.max_active = min(
+            2 + self.level_index // 2,
+            self.total_enemies
+        )
+
+        # Enemy movement delay (πιο γρήγοροι enemies)
+        self.enemy_delay = self.scaler.enemy_move_delay(self.level_index)
+
+        # --------------------------------------------------
+        # Spawn περιεχομένου πίστας
+        # --------------------------------------------------
+        self._spawn_emeralds()
+        self._spawn_gold_bags()
+
+
+    def _handle_player2_input(self, dt):
+        # --------------------------------------------------
+        # ΧΕΙΡΙΣΜΟΣ INPUT ΓΙΑ PLAYER 2 (CO-OP)
+        # --------------------------------------------------
+
+        # Αν δεν υπάρχει Player 2 ή είναι νεκρός → αγνοούμε
+        if not self.player2 or not self.player2.alive or self.lives_p2.count <= 0:
+            return
+
+        # Άμεση ανάγνωση πληκτρολογίου (WASD)
+        keys = pygame.key.get_pressed()
+
+        direction = None
+
+        # --------------------------------------------------
+        # ΚΙΝΗΣΗ (WASD)
+        # --------------------------------------------------
+        if keys[pygame.K_w]:
+            direction = Direction.UP
+        elif keys[pygame.K_s]:
+            direction = Direction.DOWN
+        elif keys[pygame.K_a]:
+            direction = Direction.LEFT
+        elif keys[pygame.K_d]:
+            direction = Direction.RIGHT
+
+        # Αν έχει πατηθεί κατεύθυνση
+        # και δεν υπάρχει cooldown κίνησης
+        if direction and self._move_cooldown <= 0:
+            self.player2.direction = direction
+
+            # Προσπάθεια μετακίνησης στο grid
+            # Κλάση: GridMovementSystem
+            if self.movement.try_move(self.player2, direction, self.level):
+                # Αν μπήκε σε νέο tile:
+                # ελέγχουμε interactions (emerald, dirt κ.λπ.)
+                self.tile_interaction.on_enter(self.player2, self.level)
+
+                # Θέτουμε cooldown για επόμενη κίνηση
+                self._move_cooldown = 0.12
+
+        # --------------------------------------------------
+        # FIRE (LEFT SHIFT)
+        # --------------------------------------------------
+        if keys[pygame.K_LSHIFT]:
+            # Αποθηκεύουμε πόσες σφαίρες υπήρχαν πριν
+            before = len(self.bullets)
+
+            # Προσπάθεια πυροβολισμού
+            # Κλάση: WeaponSystem
+            self.weapon_system.try_fire(
+                self.weapon,
+                self.player2,
+                self.bullets
+            )
+
+            # Όσες σφαίρες δημιουργήθηκαν τώρα
+            # δηλώνονται ως bullets του Player 2
+            for b in self.bullets[before:]:
+                b.owner_id = "p2"
+
+            # Αν όντως πυροβόλησε
+            if len(self.bullets) > before:
+                AudioManager.play_sound("shot")
+
+
+    def _get_closest_player(self, enemy):
+        # --------------------------------------------------
+        # ΕΠΙΛΟΓΗ ΣΤΟΧΟΥ ΓΙΑ ENEMY
+        # --------------------------------------------------
+        # Επιστρέφει τον κοντινότερο ΖΩΝΤΑΝΟ παίκτη
+        # Χρησιμοποιείται από το Enemy AI
+        # --------------------------------------------------
+
+        alive_players = []
+
+        # Player 1
+        if self.player and self.player.alive:
+            alive_players.append(self.player)
+
+        # Player 2
+        if self.player2 and self.player2.alive:
+            alive_players.append(self.player2)
+
+        # Αν δεν υπάρχει ΚΑΝΕΝΑΣ ζωντανός παίκτης
+        # → enemy δεν έχει στόχο
+        if not alive_players:
+            return None
+
+        # Manhattan distance (grid-based απόσταση)
+        def dist(p):
+            return abs(p.tile_x - enemy.tile_x) + abs(p.tile_y - enemy.tile_y)
+
+        # Επιστροφή παίκτη με τη μικρότερη απόσταση
+        return min(alive_players, key=dist)
+
+    def _render_view(self, surface, camera, focus_player):
+        # --------------------------------------------------
+        # Ζωγραφίζει μία "άποψη" του κόσμου (world view)
+        # Χρησιμοποιείται:
+        # - στο single player (μία φορά)
+        # - στο split screen (μία φορά ανά παίκτη)
+        #
+        # surface       : pygame.Surface όπου ζωγραφίζουμε
+        # camera        : Camera2D που μετατρέπει world → screen coords
+        # focus_player  : παίκτης που ακολουθεί η camera (δεν χρησιμοποιείται εδώ άμεσα)
+        # --------------------------------------------------
+
+        # Καθαρίζουμε το surface με μαύρο φόντο
+        surface.fill((0, 0, 0))
+
+        # Ζωγραφίζουμε το tilemap (χώμα, tunnels, background)
+        # Κλάση: TilemapView
+        # ΔΕΝ γνωρίζει τίποτα για παίκτες, εχθρούς ή bullets
+        self.tilemap_view.render(surface, self.level, camera)
+
+        # --------------------------------------------------
+        # ΠΑΙΚΤΕΣ (Player 1 & Player 2)
+        # --------------------------------------------------
+        # Ζωγραφίζουμε ΚΑΙ τους δύο παίκτες στο ίδιο world
+        for p in (self.player, self.player2):
+
+            # Αν ο παίκτης δεν υπάρχει (None) ή είναι νεκρός
+            # ΔΕΝ τον ζωγραφίζουμε
+            if p is None or not p.alive:
+                continue
+
+            # Flag που ελέγχει αν θα ζωγραφιστεί τελικά
+            draw_it = True
+
+            # Invulnerability blink ΜΟΝΟ για Player 1
+            # Ο Player 2 δεν έχει invulnerability
+            if p == self.player and self._invuln_timer > 0.0:
+                # Δημιουργούμε blinking effect
+                # Ανάλογα με τον χρόνο, κάποιες φορές δεν ζωγραφίζεται
+                if int(self._invuln_timer * 18) % 2 == 0:
+                    draw_it = False
+
+            if draw_it:
+                # Μετατροπή από tile coordinates σε world coordinates
+                px = p.tile_x * self.TILE_SIZE
+                py = p.tile_y * self.TILE_SIZE
+
+                # Μετατροπή από world σε screen coordinates μέσω camera
+                sx, sy = camera.world_to_screen(px, py)
+
+                # Ζωγραφίζουμε το sprite του παίκτη
+                # Κλάση: PlayerSprite
+                # Χρησιμοποιεί direction για rotation / flip
+                self.player_sprite.draw(surface, sx, sy, p.direction)
+
+        # --------------------------------------------------
+        # ENEMIES
+        # --------------------------------------------------
+        for enemy in self.enemies:
+            # Tile → world
+            ex = enemy.tile_x * self.TILE_SIZE
+            ey = enemy.tile_y * self.TILE_SIZE
+
+            # World → screen
+            sx, sy = camera.world_to_screen(ex, ey)
+
+            # Ζωγραφίζουμε τον enemy
+            # Κλάση: EnemySprite
+            # Εσωτερικά επιλέγει nobbin / hobbin sprite
+            self.enemy_sprite.draw(surface, enemy, sx, sy)
+
+        # --------------------------------------------------
+        # EMERALDS (αντικείμενα που είναι αποθηκευμένα στο tilemap)
+        # --------------------------------------------------
+        # Διατρέχουμε ΟΛΟ το grid του level
+        for y, row in enumerate(self.level.tiles):
+            for x, tile in enumerate(row):
+
+                # Αν το tile είναι emerald
+                if tile == TileType.EMERALD:
+                    # Tile → world
+                    wx = x * self.TILE_SIZE
+                    wy = y * self.TILE_SIZE
+
+                    # World → screen
+                    sx, sy = camera.world_to_screen(wx, wy)
+
+                    # Ζωγραφίζουμε emerald sprite
+                    # Κλάση: EmeraldSprite
+                    self.emerald_sprite.draw(surface, sx, sy)
+
+        # --------------------------------------------------
+        # GOLD BAGS / GOLD PILES
+        # --------------------------------------------------
+        for bag in self.gold_bags:
+
+            # Αν έχει συλλεχθεί, δεν ζωγραφίζεται
+            if bag.collected:
+                continue
+
+            # Tile → world
+            gx = bag.tile_x * self.TILE_SIZE
+            gy = bag.tile_y * self.TILE_SIZE
+
+            # World → screen
+            sx, sy = camera.world_to_screen(gx, gy)
+
+            # Ζωγραφίζουμε sack / falling sack / gold pile
+            # Κλάση: GoldBagSprite
+            self.gold_bag_sprite.draw(surface, bag, sx, sy)
+
+        # --------------------------------------------------
+        # BULLETS
+        # --------------------------------------------------
+        # Τα bullets είναι απλά τετράγωνα (όχι sprite)
+        # Αυτό βοηθά debugging και arcade αίσθηση
+        for b in self.bullets:
+            # Tile → world
+            bx = b.tile_x * self.TILE_SIZE
+            by = b.tile_y * self.TILE_SIZE
+
+            # World → screen
+            sx, sy = camera.world_to_screen(bx, by)
+
+            # Ζωγραφίζουμε μικρό λευκό τετράγωνο
+            pygame.draw.rect(
+                surface,
+                (255, 255, 255),
+                pygame.Rect(sx + 12, sy + 12, 8, 8)
+            )
+
+        # --------------------------------------------------
+        # EXPLOSIONS (particles)
+        # --------------------------------------------------
+        # Κλάση: ExplosionSystem
+        # Χρησιμοποιεί camera για σωστή τοποθέτηση
+        self.explosions.draw(surface, camera)
+
+    # ==================================================
+    # Update
+    # ==================================================
+
+    def update(self, dt):
+        # ==================================================
+        # ΓΕΝΙΚΟ UPDATE LOOP ΤΗΣ ΣΚΗΝΗΣ ΠΑΙΧΝΙΔΙΟΥ
+        #
+        # Η μέθοδος αυτή καλείται ΚΑΘΕ FRAME.
+        # Το dt (delta time) είναι ο χρόνος σε δευτερόλεπτα
+        # από το προηγούμενο frame.
+        # ==================================================
+
+        # Μείωση cooldown κίνησης παίκτη
+        self._move_cooldown = max(0.0, self._move_cooldown - dt)
+
+        # Ενημέρωση weapon cooldown
+        # Κλάση: Weapon
+        self.weapon.update(dt)
+
+        # Ενημέρωση invulnerability timer του Player 1
+        if self._invuln_timer > 0.0:
+            self._invuln_timer = max(0.0, self._invuln_timer - dt)
+
+        # ==================================================
+        # BONUS MODE
+        # ==================================================
+        # Σε bonus mode οι εχθροί αλλάζουν συμπεριφορά
+        if self.game_mode == GameMode.BONUS:
+            self.bonus_timer -= dt
+            if self.bonus_timer <= 0:
+                self.game_mode = GameMode.NORMAL
+
+        # ==================================================
+        # LEVEL COMPLETE MODE
+        # ==================================================
+        # Όταν τελειώσουν όλα τα emeralds, μπαίνουμε εδώ
+        if self.game_mode == GameMode.LEVEL_COMPLETE:
+            self.level_complete_timer -= dt
+            if self.level_complete_timer <= 0:
+                self._load_next_level()
+            return  # σταματάμε update όσο περιμένουμε
+
+        # ==================================================
+        # ΕΛΕΓΧΟΣ ΟΛΟΚΛΗΡΩΣΗΣ ΠΙΣΤΑΣ
+        # ==================================================
+        # Αν υπάρχει έστω ένα emerald στο grid, συνεχίζουμε
+        emerald_exists = any(
+            TileType.EMERALD in row for row in self.level.tiles
+        )
+
+        if not emerald_exists:
+            self.game_mode = GameMode.LEVEL_COMPLETE
+            self.level_complete_timer = self.LEVEL_COMPLETE_DELAY
+            return
+
+        # Snapshot input από InputController
+        inp = self._last_input
+
+        # ==================================================
+        # PLAYER 1 MOVEMENT
+        # ==================================================
+        if self.player.alive and inp and self._move_cooldown <= 0:
+
+            direction = None
+
+            # Ανάγνωση input και αντιστοίχιση σε Direction enum
+            if inp.up:
+                direction = Direction.UP
+            elif inp.down:
+                direction = Direction.DOWN
+            elif inp.left:
+                direction = Direction.LEFT
+            elif inp.right:
+                direction = Direction.RIGHT
+
+            if direction:
+                # Αποθήκευση direction (χρησιμοποιείται στο sprite)
+                self.player.direction = direction
+
+                # Grid-based μετακίνηση
+                # Κλάση: GridMovementSystem
+                if self.movement.try_move(self.player, direction, self.level):
+                    # Αλληλεπίδραση με tile (DIRT -> TUNNEL κ.λπ.)
+                    # Κλάση: TileInteractionSystem
+                    self.tile_interaction.on_enter(self.player, self.level)
+
+                    # Έλεγχος για emerald pickup και scoring
+                    # Κλάση: ScoreSystem
+                    self.score_system.on_player_enter(self.player, self.level)
+
+                    # Θέτουμε cooldown κίνησης
+                    self._move_cooldown = 0.12
+
+        # ==================================================
+        # PLAYER 2 EMERALD PICKUP (ΧΩΡΙΣ TileInteraction)
+        # ==================================================
+        if self.player2:
+            tx = self.player2.tile_x
+            ty = self.player2.tile_y
+
+            if self.level.get_tile(tx, ty) == TileType.EMERALD:
+                self.level.set_tile(tx, ty, TileType.TUNNEL)
+                self.score_p2.add_points(100)
+                AudioManager.play_sound("menu_select")
+
+        # ==================================================
+        # PLAYER 1 FIRE WEAPON
+        # ==================================================
+        if self.player.alive and inp and inp.fire:
+
+            before = len(self.bullets)
+
+            # Δημιουργία bullet αν το weapon επιτρέπει fire
+            # Κλάση: WeaponSystem
+            self.weapon_system.try_fire(self.weapon, self.player, self.bullets)
+
+            # Όλα τα νέα bullets ανήκουν στον Player 1
+            for b in self.bullets[before:]:
+                b.owner_id = "p1"
+
+            if len(self.bullets) > before:
+                AudioManager.play_sound("shot")
+
+        # ==================================================
+        # PLAYER 2 MOVEMENT & FIRE
+        # ==================================================
+        self._handle_player2_input(dt)
+
+        # ==================================================
+        # ENEMY SPAWN
+        # ==================================================
+        self._spawn_timer += dt
+
+        if (
+                len(self.enemies) < self.max_active
+                and self._spawn_timer >= self.spawn_delay
+        ):
+            # Δημιουργία enemy μέσω EnemySpawner
+            enemy = self.enemy_spawner.spawn()
+            enemy.move_timer = 0.0
+
+            self.enemies.append(enemy)
+            self.spawned_total += 1
+            self._spawn_timer = 0.0
+
+        # ==================================================
+        # ENEMY UPDATE
+        # ==================================================
+        for enemy in self.enemies:
+            if not enemy.alive:
+                continue
+
+            # Εναλλαγή NOBBIN / HOBBIN
+            # Κλάση: EnemyFormSystem
+            self.enemy_form_system.update(enemy, dt)
+
+            enemy.move_timer += dt
+
+            if enemy.move_timer >= self.enemy_delay:
+                # Επιλογή κοντινότερου ζωντανού παίκτη
+                target_player = self._get_closest_player(enemy)
+
+                if target_player:
+                    # AI απόφαση κίνησης
+                    # Κλάση: EnemyAISystem + EnemyBrain
+                    self.enemy_ai.update(
+                        enemies=[enemy],
+                        player=target_player,
+                        level=self.level,
+                        movement_system=self.movement,
+                        game_mode=self.game_mode,
+                    )
+
+                # Αν είναι Hobbin, σκάβει
+                self.hobbin_digging.on_enter(enemy, self.level)
+
+                enemy.move_timer = 0.0
+
+        # ==================================================
+        # BULLETS UPDATE
+        # ==================================================
+        kills = self.bullet_system.update(
+            self.bullets,
+            self.level,
+            self.enemies,
+            dt,
+        )
+
+        # ==================================================
+        # BULLET KILLS -> SCORE
+        # ==================================================
+        for enemy, owner in kills:
+            if owner == "p2":
+                self.score_p2.add_points(250)
+            else:
+                self.score.add_points(250)
+
+        # ==================================================
+        # PLAYER 1 VS ENEMY
+        # ==================================================
+        if self.player.alive and self._invuln_timer <= 0.0:
+            for enemy in self.enemies:
+                if (
+                        enemy.alive
+                        and enemy.tile_x == self.player.tile_x
+                        and enemy.tile_y == self.player.tile_y
+                ):
+                    self._handle_player_hit()
+                    break
+
+        # ==================================================
+        # PLAYER 2 VS ENEMY
+        # ==================================================
+        if self.player2 and self.lives_p2.count > 0:
+            for enemy in self.enemies:
+                if (
+                        enemy.alive
+                        and enemy.tile_x == self.player2.tile_x
+                        and enemy.tile_y == self.player2.tile_y
+                ):
+                    if not self.lives_p2.lose_life():
+                        self.player2.alive = False
+                    else:
+                        self._respawn_player2()
+                    break
+
+        # ==================================================
+        # GAME OVER CHECK
+        # ==================================================
+        if (
+                not self.player.alive
+                and (not self.player2 or not self.player2.alive)
+                and self._invuln_timer <= 0.0
+        ):
+            self.sm.set_scene(
+                "gameover",
+                {
+                    "score_p1": self.score.points,
+                    "score_p2": self.score_p2.points
+                }
+            )
+            return
+
+        # ==================================================
+        # ENEMY DEATH EXPLOSIONS
+        # ==================================================
+        alive_now = set(id(e) for e in self.enemies if e.alive)
+        dead_ids = self._alive_enemy_ids_prev - alive_now
+
+        if dead_ids:
+            for e in self.enemies:
+                if id(e) in dead_ids:
+                    self.explosions.spawn(e.tile_x, e.tile_y)
+
+        self._alive_enemy_ids_prev = alive_now
+
+        # ==================================================
+        # CLEANUP
+        # ==================================================
+        self.enemies = [e for e in self.enemies if e.alive]
+
+        # Ενημέρωση gold sack physics
+        # Κλάση: GoldBagSystem
+        self.gold_bag_system.update(self.gold_bags, self.level, dt)
+
+        # ==================================================
+        # GOLD BAG INTERACTIONS
+        # ==================================================
+        for bag in self.gold_bags:
+            if bag.collected:
+                continue
+
+            # Player 1 eats sack
+            if not bag.is_gold and not bag.falling:
+                if bag.tile_x == self.player.tile_x and bag.tile_y == self.player.tile_y:
+                    bag.collected = True
+                    self.level.set_tile(bag.tile_x, bag.tile_y, TileType.TUNNEL)
+                    AudioManager.play_sound("menu_select")
+                    continue
+
+            # Player 2 eats sack
+            if self.player2 and not bag.is_gold and not bag.falling:
+                if bag.tile_x == self.player2.tile_x and bag.tile_y == self.player2.tile_y:
+                    bag.collected = True
+                    self.level.set_tile(bag.tile_x, bag.tile_y, TileType.TUNNEL)
+                    AudioManager.play_sound("menu_select")
+                    continue
+
+            # Gold pile pickup
+            if bag.is_gold:
+                if bag.tile_x == self.player.tile_x and bag.tile_y == self.player.tile_y:
+                    bag.collected = True
+                    self.score_system.add_points(500)
+                    AudioManager.play_sound("menu_select")
+                    continue
+
+            if self.player2 and bag.is_gold:
+                if bag.tile_x == self.player2.tile_x and bag.tile_y == self.player2.tile_y:
+                    bag.collected = True
+                    self.score_p2.add_points(500)
+                    AudioManager.play_sound("menu_select")
+                    continue
+
+            # Enemy interactions with gold
+            for enemy in self.enemies:
+                if not enemy.alive:
+                    continue
+
+                if bag.tile_x != enemy.tile_x:
+                    continue
+
+                if bag.falling:
+                    y_min = min(bag.prev_tile_y, bag.tile_y)
+                    y_max = max(bag.prev_tile_y, bag.tile_y)
+
+                    if y_min <= enemy.tile_y <= y_max:
+                        enemy.alive = False
+                        self.explosions.spawn_world(
+                            enemy.tile_x * self.TILE_SIZE,
+                            enemy.tile_y * self.TILE_SIZE
+                        )
+                        self.score_system.add_points(250)
+                        break
+
+                elif bag.is_gold and bag.tile_y == enemy.tile_y:
+                    bag.collected = True
+                    break
+
+        # ==================================================
+        # CAMERA FOLLOW
+        # ==================================================
+        if self.camera_p1 and self.player.alive:
+            self.camera_p1.follow(self.player)
+
+        if self.player2 and self.player2.alive and self.camera_p2:
+            self.camera_p2.follow(self.player2)
+
+        # ==================================================
+        # PARTICLES UPDATE
+        # ==================================================
+        self.explosions.update(dt)
+
+    # ==================================================
+    # Render
+    # ==================================================
+
+    def render(self, surface):
+        # ==================================================
+        # ΜΕΘΟΔΟΣ RENDER ΤΗΣ GameScene
+        #
+        # Καλείται σε κάθε frame μετά το update().
+        # Αναλαμβάνει ΑΠΟΚΛΕΙΣΤΙΚΑ τη σχεδίαση (ΟΧΙ λογική).
+        # ==================================================
+
+        # Διαστάσεις παραθύρου
+        w, h = surface.get_size()
+
+        # ==================================================
+        # SINGLE PLAYER MODE
+        # Αν ΔΕΝ υπάρχει Player 2, ζωγραφίζουμε κανονικά
+        # σε ολόκληρη την οθόνη.
+        # ==================================================
+        if not self.player2:
+
+            # Καθαρίζουμε την οθόνη με μαύρο χρώμα
+            surface.fill((0, 0, 0))
+
+            # Σχεδίαση tilemap (χώμα, tunnels κ.λπ.)
+            # Κλάση: TilemapView
+            self.tilemap_view.render(surface, self.level, self.camera_p1)
+
+            # ==================================================
+            # PLAYER 1
+            # ==================================================
+
+            draw_player = True
+
+            # Αν ο παίκτης είναι invulnerable,
+            # εφαρμόζουμε blinking effect
+            if self._invuln_timer > 0.0 and int(self._invuln_timer * 18) % 2 == 0:
+                draw_player = False
+
+            if draw_player:
+                # Μετατροπή tile συντεταγμένων σε world pixels
+                px = self.player.tile_x * self.TILE_SIZE
+                py = self.player.tile_y * self.TILE_SIZE
+
+                # Μετατροπή world -> screen μέσω camera
+                sx, sy = self.camera_p1.world_to_screen(px, py)
+
+                # Σχεδίαση sprite παίκτη
+                # Κλάση: PlayerSprite
+                self.player_sprite.draw(surface, sx, sy, self.player.direction)
+
+            # ==================================================
+            # ENEMIES
+            # ==================================================
+            for enemy in self.enemies:
+                ex = enemy.tile_x * self.TILE_SIZE
+                ey = enemy.tile_y * self.TILE_SIZE
+                sx, sy = self.camera.world_to_screen(ex, ey)
+
+                # Σχεδίαση enemy sprite
+                # Κλάση: EnemySprite
+                self.enemy_sprite.draw(surface, enemy, sx, sy)
+
+            # ==================================================
+            # EMERALDS
+            # ==================================================
+            # Διατρέχουμε ΟΛΟ το grid και ζωγραφίζουμε
+            # όσα tiles είναι EMERALD
+            for y, row in enumerate(self.level.tiles):
+                for x, tile in enumerate(row):
+                    if tile == TileType.EMERALD:
+                        wx = x * self.TILE_SIZE
+                        wy = y * self.TILE_SIZE
+                        sx, sy = self.camera.world_to_screen(wx, wy)
+
+                        # Κλάση: EmeraldSprite
+                        self.emerald_sprite.draw(surface, sx, sy)
+
+            # ==================================================
+            # GOLD BAGS / GOLD PILES
+            # ==================================================
+            for bag in self.gold_bags:
+                if bag.collected:
+                    continue
+
+                gx = bag.tile_x * self.TILE_SIZE
+                gy = bag.tile_y * self.TILE_SIZE
+                sx, sy = self.camera.world_to_screen(gx, gy)
+
+                # Κλάση: GoldBagSprite
+                self.gold_bag_sprite.draw(surface, bag, sx, sy)
+
+            # ==================================================
+            # BULLETS
+            # ==================================================
+            # Τα bullets σχεδιάζονται απλά ως λευκά τετράγωνα
+            for b in self.bullets:
+                bx = b.tile_x * self.TILE_SIZE
+                by = b.tile_y * self.TILE_SIZE
+                sx, sy = self.camera.world_to_screen(bx, by)
+
+                pygame.draw.rect(
+                    surface,
+                    (255, 255, 255),
+                    pygame.Rect(sx + 12, sy + 12, 8, 8)
+                )
+
+            # ==================================================
+            # EXPLOSIONS (particles)
+            # ==================================================
+            # Κλάση: ExplosionSystem
+            self.explosions.draw(surface, self.camera_p1)
+
+            # ==================================================
+            # HUD (Score, Lives, Level)
+            # ==================================================
+
+            hud = f"SCORE: {self.score.points}   LIVES: {self.lives.count}"
+            hud_surf = self._font.render(hud, True, (255, 255, 255))
+            surface.blit(hud_surf, (16, 12))
+
+            level_surf = self._font.render(
+                f"LEVEL: {self.level_index}", True, (255, 255, 255)
+            )
+            surface.blit(
+                level_surf,
+                (w // 2 - level_surf.get_width() // 2, 12)
+            )
+
+            # Τερματίζουμε εδώ, ΔΕΝ πάμε σε split screen
+            return
+
+        # ==================================================
+        # SPLIT SCREEN MODE – 2 PLAYERS
+        # ==================================================
+
+        half_w = w // 2
+
+        # ==================================================
+        # LEFT VIEW – PLAYER 1
+        # ==================================================
+        left_surface = surface.subsurface((0, 0, half_w, h))
+        self._render_view(left_surface, self.camera_p1, self.player)
+
+        # ==================================================
+        # RIGHT VIEW – PLAYER 2
+        # ==================================================
+        right_surface = surface.subsurface((half_w, 0, half_w, h))
+        self._render_view(right_surface, self.camera_p2, self.player2)
+
+        # ==================================================
+        # DIVIDER LINE
+        # ==================================================
+        pygame.draw.line(
+            surface,
+            (70, 70, 70),
+            (half_w, 0),
+            (half_w, h),
+            2
+        )
+
+        # ==================================================
+        # HUD PLAYER 1
+        # ==================================================
+        hud_p1 = f"P1  SCORE: {self.score.points}   LIVES: {self.lives.count}"
+        hud_p1_surf = self._font.render(hud_p1, True, (255, 255, 255))
+        surface.blit(hud_p1_surf, (16, 12))
+
+        # ==================================================
+        # HUD PLAYER 2
+        # ==================================================
+        hud_p2 = f"P2  SCORE: {self.score_p2.points}   LIVES: {self.lives_p2.count}"
+        hud_p2_surf = self._font.render(hud_p2, True, (255, 255, 255))
+        surface.blit(
+            hud_p2_surf,
+            (w - hud_p2_surf.get_width() - 16, 12)
+        )
+
+        # ==================================================
+        # LEVEL (κεντρικά)
+        # ==================================================
+        level_surf = self._font.render(
+            f"LEVEL: {self.level_index}", True, (255, 255, 255)
+        )
+        surface.blit(
+            level_surf,
+            (w // 2 - level_surf.get_width() // 2, 12)
+        )
+
+
+
+
+
+
Index: shared/config/game_config.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/config/game_config.py b/shared/config/game_config.py
--- a/shared/config/game_config.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/config/game_config.py	(date 1767632511568)
@@ -1,0 +1,40 @@
+from dataclasses import dataclass
+
+
+@dataclass(frozen=True)
+class GameConfig:
+    """
+    Κλάση ρυθμίσεων (configuration) του παιχνιδιού.
+
+    Περιέχει βασικές παραμέτρους που αφορούν:
+    - το παράθυρο (ανάλυση)
+    - το ρυθμό ανανέωσης (FPS)
+    - τον τίτλο του παιχνιδιού
+
+    Χρησιμοποιείται κυρίως κατά την αρχικοποίηση της εφαρμογής (GameApp).
+    """
+
+    # Πλάτος παραθύρου σε pixels
+    screen_width: int = 1280
+
+    # Ύψος παραθύρου σε pixels
+    screen_height: int = 720
+
+    # Frames Per Second (FPS)
+    # Καθορίζει πόσες φορές το παιχνίδι ενημερώνεται και σχεδιάζεται ανά δευτερόλεπτο
+    fps: int = 60
+
+    # Τίτλος παραθύρου εφαρμογής
+    title: str = "Digger (Beta Version)"
+
+    @staticmethod
+    def default() -> "GameConfig":
+        """
+        Στατική μέθοδος που επιστρέφει ένα αντικείμενο GameConfig
+        με τις προεπιλεγμένες (default) ρυθμίσεις.
+
+        Χρησιμοποιείται για:
+        - καθαρή αρχικοποίηση
+        - αποφυγή hard-coded τιμών μέσα στον κώδικα
+        """
+        return GameConfig()
Index: shared/model/entity.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/entity.py b/shared/model/entity.py
--- a/shared/model/entity.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/entity.py	(date 1767632225806)
@@ -1,0 +1,35 @@
+class Entity:
+    """
+    Βασική κλάση οντότητας (Entity) του παιχνιδιού.
+
+    Αποτελεί το κοινό υπόβαθρο για όλα τα αντικείμενα που:
+    - έχουν θέση στο grid (tile_x, tile_y)
+    - μπορούν να κινηθούν
+    - μπορούν να είναι ζωντανά ή όχι
+
+    Παραδείγματα entities:
+    - Player
+    - Enemy
+    - Bullet
+    - GoldBag
+    """
+
+    def __init__(self, entity_id: str, tile_x: int, tile_y: int):
+        # Μοναδικό αναγνωριστικό της οντότητας
+        # Χρησιμοποιείται για διάκριση και debugging
+        self.entity_id = entity_id
+
+        # Οριζόντια θέση της οντότητας στο επίπεδο (σε tiles)
+        self.tile_x = tile_x
+
+        # Κατακόρυφη θέση της οντότητας στο επίπεδο (σε tiles)
+        self.tile_y = tile_y
+
+        # Κατεύθυνση προς την οποία "κοιτάζει" ή κινείται η οντότητα
+        # Μπορεί να χρησιμοποιηθεί από movement ή AI συστήματα
+        self.dir = None
+
+        # Κατάσταση ζωής της οντότητας
+        # True  -> ενεργή στο παιχνίδι
+        # False -> έχει καταστραφεί / σκοτωθεί
+        self.alive = True
Index: shared/model/level.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/level.py b/shared/model/level.py
--- a/shared/model/level.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/level.py	(date 1767632135085)
@@ -1,0 +1,91 @@
+from shared.model.types import TileType
+# Εισαγωγή του Enum TileType που περιγράφει
+# όλους τους δυνατούς τύπους πλακιδίων (χώμα, σήραγγα, διαμάντια κ.λπ.)
+
+
+class Level:
+    """
+    Κλάση που αναπαριστά μία πίστα (level) του παιχνιδιού.
+    Το επίπεδο υλοποιείται ως δισδιάστατος πίνακας tiles.
+    Κάθε tile περιγράφει τι υπάρχει σε εκείνη τη θέση.
+    """
+
+    def __init__(self, width: int, height: int):
+        # Πλάτος του επιπέδου (αριθμός στηλών)
+        self.width = width
+
+        # Ύψος του επιπέδου (αριθμός γραμμών)
+        self.height = height
+
+        # Δημιουργία δισδιάστατου πίνακα tiles
+        # Αρχικά ΟΛΟ το επίπεδο γεμίζει με χώμα (DIRT)
+        # self.tiles[y][x]
+        self.tiles = [
+            [TileType.DIRT for _ in range(width)]
+            for _ in range(height)
+        ]
+
+        # ==================================================
+        # Spawn παίκτη και αρχικό τούνελ
+        # ==================================================
+
+        # Σημείο εμφάνισης του Player 1
+        self.tiles[5][5] = TileType.SPAWN_P1
+
+        # Δημιουργία αρχικού οριζόντιου τούνελ
+        # ώστε ο παίκτης να έχει ελεύθερο χώρο στην αρχή
+        for x in range(5, 12):
+            self.tiles[5][x] = TileType.TUNNEL
+
+        # ==================================================
+        # Placeholder θέσεις για gold bags (προς δοκιμή)
+        # ==================================================
+        # Οι γραμμές αυτές είναι σχολιασμένες
+        # και μπορούν να χρησιμοποιηθούν για fixed τοποθέτηση
+        # self.tiles[6][8] = TileType.GOLD_BAG
+        # self.tiles[10][20] = TileType.GOLD_BAG
+
+        # ==================================================
+        # Ομάδες διαμαντιών (emerald clusters)
+        # ==================================================
+
+        # Πρώτο cluster διαμαντιών (2x2)
+        self.tiles[6][6] = TileType.EMERALD
+        self.tiles[6][7] = TileType.EMERALD
+        self.tiles[7][6] = TileType.EMERALD
+        self.tiles[7][7] = TileType.EMERALD
+
+        # Δεύτερο cluster διαμαντιών (2x2)
+        self.tiles[12][18] = TileType.EMERALD
+        self.tiles[12][19] = TileType.EMERALD
+        self.tiles[13][18] = TileType.EMERALD
+        self.tiles[13][19] = TileType.EMERALD
+
+    def in_bounds(self, x: int, y: int) -> bool:
+        """
+        Ελέγχει αν οι συντεταγμένες (x, y) βρίσκονται
+        εντός των ορίων του επιπέδου.
+        Χρησιμοποιείται από movement, bullets, enemies κ.λπ.
+        """
+
+        return 0 <= x < self.width and 0 <= y < self.height
+
+    def get_tile(self, x: int, y: int) -> TileType:
+        """
+        Επιστρέφει τον τύπο του tile στη θέση (x, y).
+        Δεν κάνει έλεγχο ορίων, οπότε καλείται αφού
+        προηγηθεί έλεγχος με in_bounds().
+        """
+
+        return self.tiles[y][x]
+
+    def set_tile(self, x: int, y: int, tile: TileType):
+        """
+        Θέτει (αλλάζει) τον τύπο του tile στη θέση (x, y).
+        Χρησιμοποιείται όταν:
+        - σκάβεται χώμα
+        - συλλέγεται διαμάντι
+        - πέφτει gold bag
+        """
+
+        self.tiles[y][x] = tile
Index: client/views/sprites/enemy_sprite.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/sprites/enemy_sprite.py b/client/views/sprites/enemy_sprite.py
--- a/client/views/sprites/enemy_sprite.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/sprites/enemy_sprite.py	(date 1767632992149)
@@ -1,0 +1,132 @@
+import pygame
+import os
+
+from shared.model.types import MonsterForm
+
+
+class EnemySprite:
+    """
+    Κλάση υπεύθυνη για την οπτική αναπαράσταση των εχθρών (enemies).
+
+    Η κλάση αυτή:
+    - δεν περιέχει λογική AI
+    - δεν περιέχει λογική κίνησης
+    - δεν αλλάζει την κατάσταση του enemy
+
+    Διαβάζει μόνο:
+    - τη μορφή του enemy (NOBBIN / HOBBIN)
+    - την κίνησή του στον άξονα x
+    και επιλέγει το κατάλληλο sprite.
+    """
+
+    # Σταθερό μέγεθος πλακιδίου (32x32 pixels)
+    TILE_SIZE = 32
+
+    def __init__(self):
+        # --------------------------------------------------
+        # Εντοπισμός φακέλου sprites με ασφάλεια
+        # --------------------------------------------------
+        base_dir = os.path.dirname(__file__)
+        assets_dir = os.path.join(base_dir, "..", "..", "assets", "sprites")
+
+        # ==================================================
+        # Φόρτωση sprites
+        # Θεωρούμε ότι τα βασικά sprites κοιτάνε ΑΡΙΣΤΕΡΑ
+        # ==================================================
+
+        # Sprite για NOBBIN που κοιτάει αριστερά
+        self.nobbin_left = pygame.image.load(
+            os.path.join(assets_dir, "nobbin.png")
+        ).convert_alpha()
+
+        # Sprite για NOBBIN που κοιτάει δεξιά (flip)
+        self.nobbin_right = pygame.transform.flip(
+            self.nobbin_left, True, False
+        )
+
+        # Sprite για HOBBIN που κοιτάει αριστερά
+        self.hobbin_left = pygame.image.load(
+            os.path.join(assets_dir, "hobbin.png")
+        ).convert_alpha()
+
+        # Sprite για HOBBIN που κοιτάει δεξιά (flip)
+        self.hobbin_right = pygame.transform.flip(
+            self.hobbin_left, True, False
+        )
+
+        # ==================================================
+        # Κατάσταση sprite ΑΝΑ enemy
+        # (δεν αποθηκεύεται στο μοντέλο Enemy)
+        # ==================================================
+
+        # Λεξικό που αποθηκεύει αν ο enemy κοιτάει αριστερά
+        # key: id(enemy), value: True / False
+        self._facing_left = {}
+
+        # Λεξικό που αποθηκεύει την προηγούμενη θέση x
+        # Χρησιμοποιείται για να καταλάβουμε την κατεύθυνση κίνησης
+        self._last_x = {}
+
+    # ==================================================
+    # Σχεδίαση enemy
+    # ==================================================
+    def draw(self, surface, enemy, sx, sy):
+        """
+        Σχεδιάζει τον enemy στην οθόνη.
+
+        surface : pygame Surface (οθόνη ή υπο-οθόνη)
+        enemy   : αντικείμενο Enemy (μοντέλο παιχνιδιού)
+        sx, sy  : συντεταγμένες οθόνης (screen coordinates)
+        """
+
+        # Χρησιμοποιούμε το id(enemy) ώστε να ξεχωρίζουμε
+        # διαφορετικούς enemies χωρίς να αλλάζουμε το μοντέλο
+        eid = id(enemy)
+
+        # --------------------------------------------------
+        # Αρχικοποίηση κατάστασης για νέο enemy
+        # --------------------------------------------------
+        if eid not in self._facing_left:
+            # Από προεπιλογή θεωρούμε ότι κοιτάει αριστερά
+            self._facing_left[eid] = True
+
+            # Αποθηκεύουμε την αρχική θέση x
+            self._last_x[eid] = enemy.tile_x
+
+        # --------------------------------------------------
+        # Ανίχνευση κατεύθυνσης κίνησης
+        # --------------------------------------------------
+
+        # Αν το x αυξήθηκε, ο enemy κινείται δεξιά
+        if enemy.tile_x > self._last_x[eid]:
+            self._facing_left[eid] = False
+
+        # Αν το x μειώθηκε, ο enemy κινείται αριστερά
+        elif enemy.tile_x < self._last_x[eid]:
+            self._facing_left[eid] = True
+
+        # Ενημέρωση της τελευταίας θέσης x
+        self._last_x[eid] = enemy.tile_x
+
+        # --------------------------------------------------
+        # Επιλογή sprite με βάση:
+        # 1) μορφή enemy (NOBBIN / HOBBIN)
+        # 2) κατεύθυνση (αριστερά / δεξιά)
+        # --------------------------------------------------
+        if enemy.form == MonsterForm.HOBBIN:
+            sprite = (
+                self.hobbin_left
+                if self._facing_left[eid]
+                else self.hobbin_right
+            )
+        else:
+            sprite = (
+                self.nobbin_left
+                if self._facing_left[eid]
+                else self.nobbin_right
+            )
+
+        # --------------------------------------------------
+        # Σχεδίαση sprite στην οθόνη
+        # --------------------------------------------------
+        surface.blit(sprite, (sx, sy))
Index: shared/model/lives.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/lives.py b/shared/model/lives.py
--- a/shared/model/lives.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/lives.py	(date 1767632077209)
@@ -1,0 +1,54 @@
+class Lives:
+    """
+    Κλάση που διαχειρίζεται τις ζωές του παίκτη.
+    Υποστηρίζει:
+    - αρχικό πλήθος ζωών
+    - απώλεια ζωής
+    - απόκτηση extra ζωής βάσει σκορ
+    """
+
+    def __init__(self, start_lives=3):
+        # Πλήθος ζωών που έχει ο παίκτης αυτή τη στιγμή
+        self.count = start_lives
+
+        # Όριο σκορ στο οποίο θα δοθεί η επόμενη extra ζωή
+        # Αρχικά στις 20.000 μονάδες
+        self._next_extra_at = 20000
+
+    def lose_life(self):
+        """
+        Αφαιρεί μία ζωή από τον παίκτη.
+        Επιστρέφει:
+        - True  αν απομένουν ζωές
+        - False αν ο παίκτης έμεινε χωρίς ζωές
+        """
+
+        # Μείωση του αριθμού ζωών κατά 1
+        self.count -= 1
+
+        # Έλεγχος αν υπάρχουν ακόμα ζωές
+        return self.count > 0
+
+    def try_extra_life(self, score_points):
+        """
+        Ελέγχει αν ο παίκτης δικαιούται extra ζωή
+        με βάση το συνολικό του σκορ.
+
+        Κάθε φορά που το σκορ φτάνει:
+        20.000, 40.000, 60.000, κ.ο.κ.
+        ο παίκτης κερδίζει μία επιπλέον ζωή.
+        """
+
+        # Αν το σκορ έχει φτάσει ή ξεπεράσει το όριο
+        if score_points >= self._next_extra_at:
+            # Προσθήκη μίας ζωής
+            self.count += 1
+
+            # Ορισμός νέου ορίου για την επόμενη extra ζωή
+            self._next_extra_at += 20000
+
+            # Δηλώνει ότι δόθηκε extra ζωή
+            return True
+
+        # Διαφορετικά, δεν αλλάζει κάτι
+        return False
Index: client/views/scenes/main_menu_scene.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/scenes/main_menu_scene.py b/client/views/scenes/main_menu_scene.py
--- a/client/views/scenes/main_menu_scene.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/scenes/main_menu_scene.py	(date 1767633458615)
@@ -1,0 +1,274 @@
+import pygame
+import os
+
+from shared.core.scene import Scene, SceneManager
+from shared.services.input import InputSnapshot
+from shared.services.audio_manager import AudioManager
+
+
+class MainMenuScene(Scene):
+    """
+    Κεντρική σκηνή μενού (Main Menu).
+
+    Από εδώ ο χρήστης μπορεί να:
+    - ξεκινήσει νέο παιχνίδι (1 ή 2 παίκτες)
+    - δει οδηγίες παιχνιδιού
+    - δει high scores
+    - αλλάξει ρυθμίσεις
+    - τερματίσει την εφαρμογή
+
+    Η σκηνή αυτή αποτελεί το βασικό entry point του UI.
+    """
+
+    def __init__(self, scene_manager: SceneManager, quit_callback) -> None:
+        # Αναφορά στον SceneManager για εναλλαγή σκηνών
+        self.sm = scene_manager
+
+        # Callback για ομαλό κλείσιμο της εφαρμογής
+        self.quit_callback = quit_callback
+
+        # Τίτλος παιχνιδιού (μπορεί να τεθεί δυναμικά)
+        self.title = ""
+
+        # -------------------------
+        # Λίστα επιλογών μενού
+        # -------------------------
+        # Κάθε στοιχείο είναι (κείμενο, action_id)
+        self.items = [
+            ("NEW GAME (Single Player)", "single"),
+            ("NEW GAME (Two Players)", "multi"),
+            ("HOW TO PLAY", "howto"),
+            ("HIGH SCORES", "highscores"),
+            ("SETTINGS", "settings"),
+            ("QUIT", "quit"),
+        ]
+
+        # Δείκτης τρέχουσας επιλογής
+        self.selected = 0
+
+        # -------------------------
+        # Fonts
+        # -------------------------
+        self._font_title = None
+        self._font_item = None
+        self._font_hint = None
+
+        # Background εικόνα
+        self._bg = None
+
+        # -------------------------
+        # Cooldowns input
+        # -------------------------
+        self._nav_cooldown = 0.0
+        self._confirm_cooldown = 0.0
+
+    # ==================================================
+    # Scene lifecycle
+    # ==================================================
+
+    def enter(self, payload: dict | None = None) -> None:
+        """
+        Καλείται όταν η σκηνή ενεργοποιείται.
+
+        Φορτώνει:
+        - γραμματοσειρές
+        - background
+        - αρχικοποιεί δείκτες και timers
+        """
+
+        base_dir = os.path.dirname(__file__)
+        assets_dir = os.path.join(base_dir, "..", "..", "assets")
+
+        # -------------------------
+        # Fonts
+        # -------------------------
+        fonts_dir = os.path.join(assets_dir, "fonts")
+
+        self._font_title = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 64
+        )
+
+        self._font_item = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 30
+        )
+
+        self._font_hint = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 18
+        )
+
+        # -------------------------
+        # Background
+        # -------------------------
+        screen = pygame.display.get_surface()
+        w, h = screen.get_size()
+
+        bg_path = os.path.join(assets_dir, "menu", "menu_bg.png")
+        self._bg = pygame.image.load(bg_path).convert()
+        self._bg = pygame.transform.scale(self._bg, (w, h))
+
+        # Reset κατάστασης
+        self.selected = 0
+        self._nav_cooldown = 0.0
+        self._confirm_cooldown = 0.0
+
+    def exit(self) -> None:
+        """
+        Καλείται όταν η σκηνή απενεργοποιείται.
+        Δεν απαιτείται ειδική ενέργεια.
+        """
+        pass
+
+    # ==================================================
+    # Input
+    # ==================================================
+
+    def handle_input(self, input_snapshot: InputSnapshot) -> None:
+        """
+        Αποθήκευση input snapshot του τρέχοντος frame.
+        """
+        self._last_input = input_snapshot
+
+    # ==================================================
+    # Update
+    # ==================================================
+
+    def update(self, dt: float) -> None:
+        """
+        Επεξεργασία λογικής μενού:
+        - πλοήγηση
+        - επιλογή
+        - αλλαγή σκηνών
+        """
+
+        # Ενημέρωση cooldown timers
+        self._nav_cooldown = max(0.0, self._nav_cooldown - dt)
+        self._confirm_cooldown = max(0.0, self._confirm_cooldown - dt)
+
+        # Αν δεν υπάρχει input snapshot, σταματάμε
+        inp: InputSnapshot = getattr(self, "_last_input", None)
+        if inp is None:
+            return
+
+        # -------------------------
+        # Πλοήγηση μενού
+        # -------------------------
+        if self._nav_cooldown <= 0.0:
+            if inp.up:
+                self.selected = (self.selected - 1) % len(self.items)
+                AudioManager.play_sound("menu_move")
+                self._nav_cooldown = 0.16
+
+            elif inp.down:
+                self.selected = (self.selected + 1) % len(self.items)
+                AudioManager.play_sound("menu_move")
+                self._nav_cooldown = 0.16
+
+        # -------------------------
+        # Επιβεβαίωση επιλογής
+        # -------------------------
+        if self._confirm_cooldown <= 0.0 and inp.fire:
+            AudioManager.play_sound("menu_select")
+            label, action = self.items[self.selected]
+            self._confirm_cooldown = 0.20
+
+            if action == "quit":
+                self.quit_callback()
+                return
+
+            if action == "single":
+                self.sm.set_scene("game", {"players": 1})
+                return
+
+            if action == "multi":
+                self.sm.set_scene("game", {"players": 2})
+                return
+
+            if action == "howto":
+                self.sm.set_scene("howto", {})
+                return
+
+            if action == "highscores":
+                self.sm.set_scene("highscores", {})
+                return
+
+            if action == "settings":
+                self.sm.set_scene("settings", {})
+                return
+
+    # ==================================================
+    # Render
+    # ==================================================
+
+    def render(self, surface) -> None:
+        """
+        Σχεδίαση γραφικών του main menu.
+        """
+
+        w, h = surface.get_width(), surface.get_height()
+
+        # -------------------------
+        # Background
+        # -------------------------
+        surface.blit(self._bg, (0, 0))
+
+        # -------------------------
+        # Τίτλος παιχνιδιού
+        # -------------------------
+        self._draw_glow_text(
+            surface,
+            self.title,
+            self._font_title,
+            160,
+            90,
+        )
+
+        # -------------------------
+        # Μενού επιλογών
+        # -------------------------
+        start_y = 300
+        line_h = 48
+        menu_x = int(w * 0.28)
+
+        for i, (text, _) in enumerate(self.items):
+            y = start_y + i * line_h
+
+            if i == self.selected:
+                self._draw_glow_text(surface, text, self._font_item, menu_x, y)
+            else:
+                item = self._font_item.render(text, True, (220, 220, 220))
+                rect = item.get_rect(center=(menu_x, y))
+                surface.blit(item, rect)
+
+        # -------------------------
+        # Hint
+        # -------------------------
+        hint = "UP / DOWN to navigate • SPACE to select"
+        hint_surf = self._font_hint.render(hint, True, (160, 160, 160))
+        surface.blit(
+            hint_surf,
+            (w // 2 - hint_surf.get_width() // 2, h - 50),
+        )
+
+    # ==================================================
+    # Glow effect
+    # ==================================================
+
+    def _draw_glow_text(self, surface, text, font, cx, cy):
+        """
+        Δημιουργεί glow effect για επιλεγμένο κείμενο.
+        """
+
+        glow_color = (255, 180, 80)
+        main_color = (255, 255, 255)
+
+        # Επικάλυψη glow layers
+        for alpha in (50, 35, 20):
+            glow = font.render(text, True, glow_color)
+            glow.set_alpha(alpha)
+            rect = glow.get_rect(center=(cx, cy))
+            surface.blit(glow, rect)
+
+        # Κεντρικό κείμενο
+        main = font.render(text, True, main_color)
+        rect = main.get_rect(center=(cx, cy))
+        surface.blit(main, rect)
Index: client/views/effects/explosion.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/effects/explosion.py b/client/views/effects/explosion.py
--- a/client/views/effects/explosion.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/effects/explosion.py	(date 1767633160361)
@@ -1,0 +1,183 @@
+import random
+import pygame
+
+
+class ExplosionSystem:
+    """
+    Σύστημα διαχείρισης εκρήξεων τύπου particle.
+
+    Χαρακτηριστικά:
+    - Δεν χρησιμοποιεί sprites ή εικόνες
+    - Κάθε έκρηξη αποτελείται από πολλά μικρά particles
+    - Τα particles έχουν φυσική συμπεριφορά (ταχύτητα, βαρύτητα, τριβή)
+    - Το σύστημα είναι ανεξάρτητο από το gameplay
+
+    Παρέχει τρεις βασικές λειτουργίες:
+    - spawn / spawn_world : δημιουργία έκρηξης
+    - update              : ενημέρωση φυσικής
+    - draw                : σχεδίαση στην οθόνη
+    """
+
+    def __init__(self, tile_size: int = 32):
+        # Μέγεθος πλακιδίου (tile) σε pixels
+        # Χρησιμοποιείται για μετατροπή από tile coordinates σε world coordinates
+        self.tile_size = tile_size
+
+        # Λίστα particles
+        # Κάθε particle αποθηκεύεται ως dictionary με φυσικές ιδιότητες
+        self._particles = []
+
+    def spawn(self, tile_x: int, tile_y: int, intensity: int = 18):
+        """
+        Δημιουργεί έκρηξη χρησιμοποιώντας συντεταγμένες πλακιδίων (tile coordinates).
+
+        Χρησιμοποιείται κυρίως από το GameScene, το οποίο δουλεύει σε tile επίπεδο.
+        Η μέθοδος αυτή μετατρέπει tiles → world pixels και καλεί τη spawn_world.
+        """
+
+        # Μετατροπή από tile coordinates σε world pixel coordinates
+        world_x = tile_x * self.tile_size
+        world_y = tile_y * self.tile_size
+
+        # Δημιουργία έκρηξης σε world χώρο
+        self.spawn_world(world_x, world_y, intensity)
+
+    def spawn_world(self, world_x_px: float, world_y_px: float, intensity: int = 18):
+        """
+        Δημιουργεί έκρηξη με βάση συντεταγμένες world (σε pixels).
+
+        world_x_px, world_y_px : επάνω αριστερή γωνία tile σε pixels
+        intensity              : πόσα particles θα δημιουργηθούν
+        """
+
+        # Υπολογισμός κέντρου του tile
+        # Η έκρηξη φαίνεται πιο φυσική όταν ξεκινά από το κέντρο
+        cx = world_x_px + self.tile_size / 2
+        cy = world_y_px + self.tile_size / 2
+
+        # Δημιουργία πολλών particles
+        for _ in range(intensity):
+
+            # Τυχαία γωνία εκτόξευσης (0 έως 2π)
+            angle = random.uniform(0.0, 6.28318)
+
+            # Τυχαία αρχική ταχύτητα
+            speed = random.uniform(90.0, 240.0)
+
+            # Υπολογισμός διανύσματος ταχύτητας με περιστροφή
+            vx = (
+                speed
+                * random.uniform(0.6, 1.0)
+                * pygame.math.Vector2(1, 0).rotate_rad(angle).x
+            )
+            vy = (
+                speed
+                * random.uniform(0.6, 1.0)
+                * pygame.math.Vector2(1, 0).rotate_rad(angle).y
+            )
+
+            # Δημιουργία particle ως dictionary
+            self._particles.append({
+                # Θέση (με μικρή τυχαιότητα)
+                "x": cx + random.uniform(-3, 3),
+                "y": cy + random.uniform(-3, 3),
+
+                # Ταχύτητα
+                "vx": vx,
+                "vy": vy,
+
+                # Συνολικός χρόνος ζωής
+                "life": random.uniform(0.25, 0.55),
+
+                # Χρόνος που έχει περάσει
+                "ttl": 0.0,
+
+                # Ακτίνα particle (pixels)
+                "r": random.randint(2, 4),
+
+                # Τύπος particle (οπτική διαφοροποίηση)
+                "kind": random.choice(["spark", "dust"]),
+            })
+
+    def update(self, dt: float):
+        """
+        Ενημέρωση φυσικής των particles.
+
+        dt : χρόνος που πέρασε από το προηγούμενο frame (σε δευτερόλεπτα)
+        """
+
+        # Συντελεστής "βαρύτητας"
+        g = 420.0
+
+        # Λίστα για τα ζωντανά particles
+        alive = []
+
+        for p in self._particles:
+            # Αύξηση χρόνου ζωής
+            p["ttl"] += dt
+
+            # Αν το particle έχει ξεπεράσει τον χρόνο ζωής του, απορρίπτεται
+            if p["ttl"] >= p["life"]:
+                continue
+
+            # Εφαρμογή βαρύτητας στην κατακόρυφη ταχύτητα
+            p["vy"] += g * dt
+
+            # Ενημέρωση θέσης
+            p["x"] += p["vx"] * dt
+            p["y"] += p["vy"] * dt
+
+            # Μικρή τριβή (drag) για πιο φυσική κίνηση
+            p["vx"] *= (1.0 - 1.6 * dt)
+            p["vy"] *= (1.0 - 1.2 * dt)
+
+            # Το particle παραμένει ενεργό
+            alive.append(p)
+
+        # Αντικατάσταση λίστας με μόνο τα ζωντανά particles
+        self._particles = alive
+
+    def draw(self, surface, camera):
+        """
+        Σχεδιάζει όλα τα ενεργά particles στην οθόνη.
+
+        surface : επιφάνεια pygame (συνήθως η οθόνη)
+        camera  : Camera2D για μετατροπή world → screen
+        """
+
+        # Κάθε particle σχεδιάζεται σε μικρή προσωρινή επιφάνεια
+        # Αυτό επιτρέπει alpha blending χωρίς να επηρεάζει την κύρια οθόνη
+        for p in self._particles:
+
+            # Υπολογισμός ποσοστού ζωής (0.0 → 1.0)
+            t = p["ttl"] / max(0.0001, p["life"])
+
+            # Fade-out όσο πλησιάζει στο τέλος ζωής
+            alpha = int(255 * (1.0 - t))
+            if alpha <= 0:
+                continue
+
+            # Μετατροπή από world σε screen coordinates
+            sx, sy = camera.world_to_screen(p["x"], p["y"])
+
+            # Επιλογή χρώματος ανάλογα με τον τύπο particle
+            if p["kind"] == "spark":
+                color = (255, 210, 90)
+            else:
+                color = (180, 140, 90)
+
+            r = p["r"]
+
+            # Δημιουργία προσωρινής επιφάνειας με διαφάνεια
+            tmp = pygame.Surface((r * 2 + 2, r * 2 + 2), pygame.SRCALPHA)
+
+            # Σχεδίαση κύκλου με alpha
+            pygame.draw.circle(
+                tmp,
+                (*color, alpha),
+                (r + 1, r + 1),
+                r
+            )
+
+            # Σχεδίαση του particle στην κύρια επιφάνεια
+            surface.blit(tmp, (sx - r, sy - r))
Index: client/views/tilemap_view.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/tilemap_view.py b/client/views/tilemap_view.py
--- a/client/views/tilemap_view.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/tilemap_view.py	(date 1767632738172)
@@ -1,0 +1,114 @@
+import pygame
+import os
+
+# --------------------------------------------------
+# Τύποι πλακιδίων (χώμα, tunnel κ.λπ.)
+# --------------------------------------------------
+from shared.model.types import TileType
+
+
+class TilemapView:
+    """
+    Υπεύθυνη κλάση για την ΟΠΤΙΚΗ απεικόνιση του tilemap.
+
+    Δεν περιέχει καμία λογική gameplay.
+    Απλώς:
+    - διαβάζει τα tiles του Level
+    - τα μετατρέπει σε εικόνες
+    - τα σχεδιάζει στην οθόνη με βάση την κάμερα
+    """
+
+    def __init__(self, tile_size: int):
+        # Μέγεθος πλακιδίου (π.χ. 32x32 pixels)
+        self.tile_size = tile_size
+
+        # Υπολογισμός διαδρομής assets
+        base_dir = os.path.dirname(__file__)
+        assets_dir = os.path.join(base_dir, "..", "assets", "tiles")
+
+        # --------------------------------------------------
+        # Φόρτωση εικόνων πλακιδίων
+        # --------------------------------------------------
+
+        # Εικόνα grass (χρησιμοποιείται στην πάνω σειρά)
+        self.grass_tile = pygame.image.load(
+            os.path.join(assets_dir, "grass.png")
+        ).convert()
+
+        # Εικόνα dirt (χώμα)
+        self.dirt_tile = pygame.image.load(
+            os.path.join(assets_dir, "dirt.png")
+        ).convert()
+
+        # Εικόνα μπλε background (εκτός χάρτη)
+        self.blue_bg = pygame.image.load(
+            os.path.join(assets_dir, "blue.png")
+        ).convert()
+
+        # --------------------------------------------------
+        # Tunnel tile = μαύρο πλακίδιο
+        # Δημιουργείται δυναμικά, δεν φορτώνεται από αρχείο
+        # --------------------------------------------------
+        self.black_tile = pygame.Surface((tile_size, tile_size))
+        self.black_tile.fill((0, 0, 0))
+
+    def render(self, surface, level, camera):
+        """
+        Σχεδιάζει ΟΛΟ το tilemap στην οθόνη.
+
+        surface : pygame Surface (η οθόνη ή υπο-οθόνη)
+        level   : αντικείμενο Level (δεδομένα map)
+        camera  : Camera2D (μετατροπή world → screen)
+        """
+
+        # Αριθμός γραμμών και στηλών του map
+        rows = level.height
+        cols = level.width
+
+        # --------------------------------------------------
+        # Γέμισμα background εκτός map με μπλε χρώμα
+        # --------------------------------------------------
+        surface.blit(
+            pygame.transform.scale(self.blue_bg, surface.get_size()),
+            (0, 0),
+        )
+
+        # --------------------------------------------------
+        # Διπλός βρόχος: traversal όλων των tiles
+        # --------------------------------------------------
+        for y in range(rows):
+            for x in range(cols):
+                # Τύπος πλακιδίου από το Level
+                tile = level.tiles[y][x]
+
+                # Συντεταγμένες στον κόσμο (world coordinates)
+                world_x = x * self.tile_size
+                world_y = y * self.tile_size
+
+                # Μετατροπή world → screen μέσω κάμερας
+                sx, sy = camera.world_to_screen(world_x, world_y)
+
+                # --------------------------------------------------
+                # Απόρριψη πλακιδίων εκτός οθόνης
+                # --------------------------------------------------
+                if sx + self.tile_size < 0 or sy + self.tile_size < 0:
+                    continue
+
+                # --------------------------------------------------
+                # TUNNEL → μαύρο πλακίδιο
+                # --------------------------------------------------
+                if tile == TileType.TUNNEL:
+                    surface.blit(self.black_tile, (sx, sy))
+                    continue
+
+                # --------------------------------------------------
+                # Πάνω σειρά του map → grass
+                # --------------------------------------------------
+                if y == 0:
+                    surface.blit(self.grass_tile, (sx, sy))
+                    continue
+
+                # --------------------------------------------------
+                # Όλα τα υπόλοιπα tiles → dirt
+                # --------------------------------------------------
+                surface.blit(self.dirt_tile, (sx, sy))
Index: client/views/scenes/gameover_scene.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/scenes/gameover_scene.py b/client/views/scenes/gameover_scene.py
--- a/client/views/scenes/gameover_scene.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/scenes/gameover_scene.py	(date 1767633650102)
@@ -1,0 +1,170 @@
+import pygame
+import os
+from shared.core.scene import Scene
+from shared.persistence.score_repository import ScoreRepository
+
+
+class GameOverScene(Scene):
+    """
+    Σκηνή Game Over.
+
+    Εμφανίζεται όταν το παιχνίδι τελειώσει (loss condition).
+    Παρουσιάζει:
+    - Τον τίτλο GAME OVER
+    - Το τελικό σκορ Player 1 και Player 2
+    - Οδηγία επιστροφής στο Main Menu
+
+    Δεν επιτρέπει άλλη ενέργεια εκτός από ESC → επιστροφή στο menu.
+    """
+
+    def __init__(self, scene_manager):
+        # Αναφορά στον SceneManager για αλλαγή σκηνών
+        self.sm = scene_manager
+
+        # Repository για αποθήκευση / ανάγνωση scores
+        # (μπορεί να χρησιμοποιηθεί για μελλοντική επέκταση)
+        self.repo = ScoreRepository()
+
+        # -------------------------
+        # Paths για assets
+        # -------------------------
+        base_dir = os.path.dirname(__file__)
+        assets_dir = os.path.join(base_dir, "..", "..", "assets")
+        fonts_dir = os.path.join(assets_dir, "fonts")
+        menu_dir = os.path.join(assets_dir, "menu")
+
+        # -------------------------
+        # Background εικόνα
+        # -------------------------
+        # Χρησιμοποιείται το ίδιο background με το menu
+        self.bg = pygame.image.load(
+            os.path.join(menu_dir, "menu_bg.png")
+        ).convert()
+
+        # -------------------------
+        # Fonts
+        # -------------------------
+        # Μεγάλη γραμματοσειρά για τον τίτλο GAME OVER
+        self.font_title = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 64
+        )
+
+        # Μικρότερη γραμματοσειρά για σκορ και οδηγίες
+        self.font = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 24
+        )
+
+        # -------------------------
+        # Κατάσταση σκηνής
+        # -------------------------
+        self.score = 0          # (δεν χρησιμοποιείται άμεσα, κρατιέται για επεκτασιμότητα)
+        self._cooldown = 0.0    # cooldown για αποφυγή άμεσης εξόδου
+        self._input = None      # τελευταίο InputSnapshot
+
+    # =========================================
+    # Scene interface
+    # =========================================
+
+    def enter(self, payload=None):
+        """
+        Καλείται όταν η σκηνή Game Over ενεργοποιείται.
+
+        Το payload περιέχει τα τελικά σκορ των παικτών.
+        """
+        payload = payload or {}
+
+        # Ανάκτηση σκορ από το payload
+        self.score_p1 = payload.get("score_p1", 0)
+        self.score_p2 = payload.get("score_p2", 0)
+
+        # Μικρή καθυστέρηση ώστε να μη φύγει άμεσα
+        # αν ο παίκτης κρατά πατημένο ESC
+        self._cooldown = 0.4
+
+    def exit(self):
+        """
+        Καλείται όταν η σκηνή απενεργοποιείται.
+        Δεν απαιτείται καθαρισμός.
+        """
+        pass
+
+    def handle_input(self, input_snapshot):
+        """
+        Αποθηκεύει το input του τρέχοντος frame.
+        """
+        self._input = input_snapshot
+
+    # =========================================
+    # Update / Render
+    # =========================================
+
+    def update(self, dt):
+        """
+        Ελέγχει το input και επιτρέπει επιστροφή
+        στο Main Menu μόνο μετά το cooldown.
+        """
+
+        # Μείωση cooldown
+        self._cooldown = max(0, self._cooldown - dt)
+
+        # Όσο υπάρχει cooldown, αγνοούμε input
+        if self._cooldown > 0:
+            return
+
+        if not self._input:
+            return
+
+        # ΜΟΝΟ ESC (pause) → επιστροφή στο menu
+        if self._input.pause:
+            self.sm.set_scene("menu", {})
+
+    def render(self, surface):
+        """
+        Σχεδίαση της σκηνής Game Over.
+        """
+
+        # -------------------------
+        # Background
+        # -------------------------
+        surface.blit(self.bg, (0, 0))
+        w = surface.get_width()
+
+        # -------------------------
+        # Τίτλος GAME OVER
+        # -------------------------
+        title = self.font_title.render(
+            "GAME OVER", True, (255, 255, 255)
+        )
+
+        surface.blit(
+            title,
+            (w // 2 - title.get_width() // 2 + 160, 140)
+        )
+
+        # -------------------------
+        # Εμφάνιση σκορ παικτών
+        # -------------------------
+        score_txt = self.font.render(
+            f"P1: {self.score_p1}   P2: {self.score_p2}",
+            True,
+            (255, 255, 255)
+        )
+
+        surface.blit(
+            score_txt,
+            (w // 2 - score_txt.get_width() // 2 + 160, 240)
+        )
+
+        # -------------------------
+        # Οδηγία επιστροφής
+        # -------------------------
+        info = self.font.render(
+            "ESC: MAIN MENU",
+            True,
+            (200, 200, 200)
+        )
+
+        surface.blit(
+            info,
+            (w // 2 - info.get_width() // 2 + 160, 340)
+        )
Index: client/views/scenes/settings_scene.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/scenes/settings_scene.py b/client/views/scenes/settings_scene.py
--- a/client/views/scenes/settings_scene.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/scenes/settings_scene.py	(date 1767633389540)
@@ -1,0 +1,246 @@
+import pygame
+import os
+
+from shared.core.scene import Scene, SceneManager
+from shared.services.input import InputSnapshot
+from shared.services.audio_manager import AudioManager
+
+
+class SettingsScene(Scene):
+    """
+    Σκηνή ρυθμίσεων (Settings).
+
+    Η σκηνή αυτή επιτρέπει στον χρήστη να:
+    - απενεργοποιήσει όλους τους ήχους
+    - ενεργοποιήσει ξανά όλους τους ήχους
+    - επιστρέψει στο κεντρικό μενού με ESC
+
+    Δεν περιλαμβάνει gameplay λογική.
+    Ανήκει καθαρά στο UI / Menu layer του παιχνιδιού.
+    """
+
+    def __init__(self, scene_manager: SceneManager) -> None:
+        # Αποθήκευση του SceneManager για αλλαγή σκηνών
+        self.sm = scene_manager
+
+        # -------------------------
+        # Λίστα επιλογών μενού
+        # -------------------------
+        # Κάθε στοιχείο είναι (κείμενο, action_id)
+        self.items = [
+            ("MUTE ALL SOUNDS", "mute"),
+            ("UNMUTE ALL SOUNDS", "unmute"),
+            # ("BACK", "back"),  # δεν χρειάζεται, χρησιμοποιούμε ESC
+        ]
+
+        # Δείκτης επιλεγμένου στοιχείου
+        self.selected = 0
+
+        # -------------------------
+        # Πόροι γραφικών
+        # -------------------------
+        self._font_item = None
+        self._font_hint = None
+        self._bg = None
+
+        # -------------------------
+        # Cooldowns για input
+        # -------------------------
+        # Αποτρέπουν την υπερβολικά γρήγορη επανάληψη ενεργειών
+        self._nav_cooldown = 0.0
+        self._confirm_cooldown = 0.0
+        self._back_cooldown = 0.0
+
+    # ==================================================
+    # Scene lifecycle
+    # ==================================================
+
+    def enter(self, payload: dict | None = None) -> None:
+        """
+        Καλείται όταν η σκηνή γίνεται ενεργή.
+
+        Φορτώνει:
+        - γραμματοσειρές
+        - background
+        - αρχικοποιεί επιλογές και timers
+        """
+
+        # Εντοπισμός φακέλου assets
+        base_dir = os.path.dirname(__file__)
+        assets_dir = os.path.join(base_dir, "..", "..", "assets")
+
+        # -------------------------
+        # Fonts (ίδιες με main menu)
+        # -------------------------
+        fonts_dir = os.path.join(assets_dir, "fonts")
+
+        self._font_item = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 30
+        )
+
+        self._font_hint = pygame.font.Font(
+            os.path.join(fonts_dir, "Orbitron-Bold.ttf"), 18
+        )
+
+        # -------------------------
+        # Background εικόνα
+        # -------------------------
+        screen = pygame.display.get_surface()
+        w, h = screen.get_size()
+
+        bg_path = os.path.join(assets_dir, "menu", "menu_bg.png")
+        self._bg = pygame.image.load(bg_path).convert()
+        self._bg = pygame.transform.scale(self._bg, (w, h))
+
+        # -------------------------
+        # Reset κατάστασης
+        # -------------------------
+        self.selected = 0
+        self._nav_cooldown = 0.0
+        self._confirm_cooldown = 0.0
+        self._back_cooldown = 0.25
+
+    def exit(self) -> None:
+        """
+        Καλείται όταν φεύγουμε από τη σκηνή.
+        Δεν απαιτείται κάποια ειδική ενέργεια εδώ.
+        """
+        pass
+
+    # ==================================================
+    # Input
+    # ==================================================
+
+    def handle_input(self, input_snapshot: InputSnapshot) -> None:
+        """
+        Αποθηκεύει το InputSnapshot του τρέχοντος frame.
+        Η επεξεργασία γίνεται στο update().
+        """
+        self._last_input = input_snapshot
+
+    # ==================================================
+    # Update
+    # ==================================================
+
+    def update(self, dt: float) -> None:
+        """
+        Επεξεργασία λογικής της σκηνής:
+        - πλοήγηση στο μενού
+        - επιλογή ενέργειας
+        - επιστροφή στο main menu
+        """
+
+        # Μείωση των cooldown timers
+        self._nav_cooldown = max(0.0, self._nav_cooldown - dt)
+        self._confirm_cooldown = max(0.0, self._confirm_cooldown - dt)
+        self._back_cooldown = max(0.0, self._back_cooldown - dt)
+
+        # Αν δεν υπάρχει input snapshot, σταματάμε
+        inp: InputSnapshot = getattr(self, "_last_input", None)
+        if inp is None:
+            return
+
+        # -------------------------
+        # Πλοήγηση (UP / DOWN)
+        # -------------------------
+        if self._nav_cooldown <= 0.0:
+            if inp.up:
+                self.selected = (self.selected - 1) % len(self.items)
+                AudioManager.play_sound("menu_move")
+                self._nav_cooldown = 0.16
+
+            elif inp.down:
+                self.selected = (self.selected + 1) % len(self.items)
+                AudioManager.play_sound("menu_move")
+                self._nav_cooldown = 0.16
+
+        # -------------------------
+        # Επιβεβαίωση (SPACE)
+        # -------------------------
+        if self._confirm_cooldown <= 0.0 and inp.fire:
+            AudioManager.play_sound("menu_select")
+            _, action = self.items[self.selected]
+            self._confirm_cooldown = 0.25
+
+            if action == "mute":
+                AudioManager.mute_all()
+
+            elif action == "unmute":
+                AudioManager.unmute_all()
+
+        # -------------------------
+        # ESC → επιστροφή στο menu
+        # -------------------------
+        if inp.pause and self._back_cooldown <= 0.0:
+            self.sm.set_scene("menu", {})
+            self._back_cooldown = 0.25
+
+    # ==================================================
+    # Render
+    # ==================================================
+
+    def render(self, surface) -> None:
+        """
+        Σχεδίαση της σκηνής:
+        - background
+        - επιλογές
+        - hint στο κάτω μέρος
+        """
+
+        w, h = surface.get_width(), surface.get_height()
+
+        # -------------------------
+        # Background
+        # -------------------------
+        surface.blit(self._bg, (0, 0))
+
+        # -------------------------
+        # Μενού επιλογών
+        # -------------------------
+        start_y = h // 2 - 60
+        line_h = 52
+        cx = w // 2
+
+        for i, (text, _) in enumerate(self.items):
+            y = start_y + i * line_h
+
+            if i == self.selected:
+                self._draw_glow_text(surface, text, self._font_item, cx, y)
+            else:
+                item = self._font_item.render(text, True, (220, 220, 220))
+                rect = item.get_rect(center=(cx, y))
+                surface.blit(item, rect)
+
+        # -------------------------
+        # Hint
+        # -------------------------
+        hint = "UP / DOWN to navigate • SPACE to select • ESC to return"
+        hint_surf = self._font_hint.render(hint, True, (160, 160, 160))
+        surface.blit(
+            hint_surf,
+            (w // 2 - hint_surf.get_width() // 2, h - 60),
+        )
+
+    # ==================================================
+    # Glow effect
+    # ==================================================
+
+    def _draw_glow_text(self, surface, text, font, cx, cy):
+        """
+        Βοηθητική μέθοδος για glow effect στο επιλεγμένο item.
+        """
+
+        glow_color = (255, 180, 80)
+        main_color = (255, 255, 255)
+
+        # Πολλαπλά layers glow με διαφορετική διαφάνεια
+        for alpha in (50, 35, 20):
+            glow = font.render(text, True, glow_color)
+            glow.set_alpha(alpha)
+            rect = glow.get_rect(center=(cx, cy))
+            surface.blit(glow, rect)
+
+        # Κεντρικό κείμενο
+        main = font.render(text, True, main_color)
+        rect = main.get_rect(center=(cx, cy))
+        surface.blit(main, rect)
Index: client/input/input_manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/input/input_manager.py b/client/input/input_manager.py
--- a/client/input/input_manager.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/input/input_manager.py	(date 1767633227337)
@@ -1,0 +1,99 @@
+import pygame
+from shared.services.input import InputSnapshot
+
+
+class InputManager:
+    """
+    Η κλάση InputManager είναι υπεύθυνη για:
+    - τη συλλογή των γεγονότων (events) από το pygame
+    - τη μετατροπή τους σε μία ενιαία κατάσταση εισόδου (InputSnapshot)
+
+    Ουσιαστικά λειτουργεί ως "μεταφραστής" μεταξύ:
+    pygame events → λογική εισόδου του παιχνιδιού
+    """
+
+    def __init__(self) -> None:
+        # Δημιουργούμε ένα αντικείμενο InputSnapshot
+        # Το snapshot αυτό θα ενημερώνεται συνεχώς
+        # και θα επιστρέφεται σε κάθε frame
+        self._snapshot = InputSnapshot()
+
+    def process_events(self) -> InputSnapshot:
+        """
+        Επεξεργάζεται όλα τα pygame events του τρέχοντος frame
+        και ενημερώνει το InputSnapshot.
+
+        Επιστρέφει:
+        - ένα InputSnapshot που περιγράφει
+          ποια πλήκτρα είναι πατημένα αυτή τη στιγμή
+        """
+
+        # Διατρέχουμε όλα τα γεγονότα που έχει συλλέξει το pygame
+        for event in pygame.event.get():
+
+            # Αν ο χρήστης πατήσει το Χ του παραθύρου
+            # τερματίζουμε άμεσα την εφαρμογή
+            if event.type == pygame.QUIT:
+                raise SystemExit
+
+            # =========================
+            # ΠΑΤΗΜΑ ΠΛΗΚΤΡΟΥ
+            # =========================
+            if event.type == pygame.KEYDOWN:
+
+                # Πάνω βέλος → κίνηση προς τα πάνω
+                if event.key == pygame.K_UP:
+                    self._snapshot.up = True
+
+                # Κάτω βέλος → κίνηση προς τα κάτω
+                elif event.key == pygame.K_DOWN:
+                    self._snapshot.down = True
+
+                # Αριστερό βέλος → κίνηση αριστερά
+                elif event.key == pygame.K_LEFT:
+                    self._snapshot.left = True
+
+                # Δεξί βέλος → κίνηση δεξιά
+                elif event.key == pygame.K_RIGHT:
+                    self._snapshot.right = True
+
+                # Escape → pause / επιστροφή σε menu
+                elif event.key == pygame.K_ESCAPE:
+                    self._snapshot.pause = True
+
+                # Space → πυροβολισμός (fire)
+                elif event.key == pygame.K_SPACE:
+                    self._snapshot.fire = True   # FIRE DOWN
+
+            # =========================
+            # ΑΦΗΝΩ ΠΛΗΚΤΡΟ
+            # =========================
+            elif event.type == pygame.KEYUP:
+
+                # Αφήνουμε το πάνω βέλος
+                if event.key == pygame.K_UP:
+                    self._snapshot.up = False
+
+                # Αφήνουμε το κάτω βέλος
+                elif event.key == pygame.K_DOWN:
+                    self._snapshot.down = False
+
+                # Αφήνουμε το αριστερό βέλος
+                elif event.key == pygame.K_LEFT:
+                    self._snapshot.left = False
+
+                # Αφήνουμε το δεξί βέλος
+                elif event.key == pygame.K_RIGHT:
+                    self._snapshot.right = False
+
+                # Αφήνουμε το Escape
+                elif event.key == pygame.K_ESCAPE:
+                    self._snapshot.pause = False
+
+                # Αφήνουμε το Space
+                elif event.key == pygame.K_SPACE:
+                    self._snapshot.fire = False  # FIRE UP
+
+        # Επιστρέφουμε το ενημερωμένο snapshot
+        # Το ίδιο αντικείμενο χρησιμοποιείται σε όλο το frame
+        return self._snapshot
Index: client/views/camera.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/client/views/camera.py b/client/views/camera.py
--- a/client/views/camera.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/client/views/camera.py	(date 1767632792722)
@@ -1,0 +1,56 @@
+class Camera2D:
+    """
+    Κλάση κάμερας 2D.
+
+    Η Camera2D είναι υπεύθυνη για τη μετατροπή συντεταγμένων
+    από τον «κόσμο του παιχνιδιού» (world coordinates)
+    σε συντεταγμένες οθόνης (screen coordinates).
+
+    Δεν σχεδιάζει τίποτα.
+    Δεν γνωρίζει tiles, enemies ή gameplay.
+    Απλώς κρατά τη θέση της κάμερας.
+    """
+
+    def __init__(self, screen_w, screen_h, tile_size):
+        # Πλάτος οθόνης σε pixels
+        self.screen_w = screen_w
+
+        # Ύψος οθόνης σε pixels
+        self.screen_h = screen_h
+
+        # Μέγεθος πλακιδίου (π.χ. 32 pixels)
+        self.tile_size = tile_size
+
+        # Τρέχουσα θέση κάμερας στον κόσμο (πάνω αριστερή γωνία)
+        # Εκφράζεται σε pixels
+        self.x = 0
+        self.y = 0
+
+    def follow(self, entity):
+        """
+        Κεντράρει την κάμερα πάνω σε ένα entity (π.χ. player).
+
+        Υπολογίζει τη θέση της κάμερας έτσι ώστε
+        το entity να εμφανίζεται στο κέντρο της οθόνης.
+        """
+
+        # Μετατροπή tile συντεταγμένων του entity σε pixels
+        world_x = entity.tile_x * self.tile_size
+        world_y = entity.tile_y * self.tile_size
+
+        # Η κάμερα μετακινείται έτσι ώστε το entity
+        # να βρίσκεται στο κέντρο της οθόνης
+        self.x = world_x - self.screen_w // 2
+        self.y = world_y - self.screen_h // 2
+
+    def world_to_screen(self, wx, wy):
+        """
+        Μετατρέπει συντεταγμένες κόσμου (world)
+        σε συντεταγμένες οθόνης (screen).
+
+        Αυτή η μέθοδος χρησιμοποιείται από ΟΛΑ τα render συστήματα.
+        """
+
+        # Αφαιρούμε τη θέση της κάμερας από τις world συντεταγμένες
+        # ώστε να πάρουμε screen συντεταγμένες
+        return wx - self.x, wy - self.y
Index: shared/model/weapon.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/model/weapon.py b/shared/model/weapon.py
--- a/shared/model/weapon.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/model/weapon.py	(date 1767631591030)
@@ -1,0 +1,60 @@
+class Weapon:
+    """
+    Η κλάση Weapon αναπαριστά ένα όπλο με μηχανισμό cooldown.
+
+    Ο ρόλος της είναι να ελέγχει:
+    - πότε επιτρέπεται να πυροβολήσει ο παίκτης
+    - πόσος χρόνος πρέπει να περάσει ανάμεσα σε δύο βολές
+
+    Δεν γνωρίζει ΤΙ πυροβολεί ούτε ΠΟΥ,
+    αλλά μόνο το ΠΟΤΕ επιτρέπεται να πυροβολήσει.
+    """
+
+    def __init__(self, cooldown=2.0):
+        """
+        Constructor της κλάσης Weapon.
+
+        cooldown:
+        ο χρόνος (σε δευτερόλεπτα) που πρέπει να περάσει
+        ανάμεσα σε δύο πυροβολισμούς.
+        """
+
+        # Αποθηκεύουμε το cooldown του όπλου
+        self.cooldown = cooldown
+
+        # Εσωτερικός χρονομετρητής που μετρά
+        # πόσος χρόνος απομένει μέχρι το επόμενο επιτρεπτό shot
+        self._timer = 0.0
+
+    def update(self, dt):
+        """
+        Ενημερώνει τον εσωτερικό χρονομετρητή του όπλου.
+
+        dt:
+        ο χρόνος που πέρασε από το προηγούμενο frame (σε δευτερόλεπτα)
+        """
+
+        # Μειώνουμε τον χρονομετρητή κατά dt
+        # Δεν επιτρέπουμε να γίνει αρνητικός
+        self._timer = max(0.0, self._timer - dt)
+
+    def can_fire(self):
+        """
+        Ελέγχει αν το όπλο μπορεί να πυροβολήσει αυτή τη στιγμή.
+
+        Επιστρέφει:
+        True  -> το όπλο είναι έτοιμο
+        False -> το όπλο βρίσκεται ακόμα σε cooldown
+        """
+
+        return self._timer <= 0.0
+
+    def fired(self):
+        """
+        Καλείται όταν το όπλο πυροβολήσει.
+
+        Θέτει τον χρονομετρητή ίσο με το cooldown,
+        ξεκινώντας νέο κύκλο αναμονής.
+        """
+
+        self._timer = self.cooldown
Index: shared/services/difficulty_scaler.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/difficulty_scaler.py b/shared/services/difficulty_scaler.py
--- a/shared/services/difficulty_scaler.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/difficulty_scaler.py	(date 1767631323006)
@@ -1,0 +1,117 @@
+class DifficultyScaler:
+    """
+    Η κλάση DifficultyScaler είναι υπεύθυνη για ΟΛΗ
+    τη λογική κλιμάκωσης της δυσκολίας του παιχνιδιού.
+
+    Για κάθε πίστα (level) υπολογίζει:
+    - πόσα διαμάντια υπάρχουν
+    - πόσα σακιά χρυσού υπάρχουν
+    - πόσοι εχθροί θα εμφανιστούν
+    - πόσο γρήγορα κινούνται οι εχθροί
+    - αν υπάρχει επόμενη πίστα
+
+    Με αυτόν τον τρόπο:
+    - η δυσκολία είναι συγκεντρωμένη σε ΕΝΑ σημείο
+    - το υπόλοιπο παιχνίδι παραμένει καθαρό και απλό
+    """
+
+    # Μέγιστος αριθμός πιστών που υποστηρίζει το παιχνίδι
+    MAX_LEVEL = 20
+
+    # =========================
+    # Διαμάντια (Emeralds)
+    # =========================
+    def diamonds_for_level(self, level: int) -> int:
+        """
+        Υπολογίζει πόσα διαμάντια περιέχει η πίστα.
+
+        Κανόνας:
+        - Στην πίστα 1 υπάρχουν 40 διαμάντια
+        - Σε κάθε επόμενη πίστα προστίθενται +10
+
+        level : ο αριθμός της πίστας
+        επιστρέφει : πλήθος διαμαντιών
+        """
+
+        # Βασικός αριθμός διαμαντιών
+        # +10 για κάθε πίστα μετά την πρώτη
+        return 40 + (level - 1) * 10
+
+    # =========================
+    # Σακιά χρυσού
+    # =========================
+    def gold_bags_for_level(self, level: int) -> int:
+        """
+        Υπολογίζει πόσα σακιά χρυσού υπάρχουν στην πίστα.
+
+        Κανόνας:
+        - Στην πίστα 1 υπάρχουν 5 σακιά
+        - Σε κάθε επόμενη πίστα προστίθενται +2
+
+        level : ο αριθμός της πίστας
+        επιστρέφει : πλήθος σακιών
+        """
+
+        # Ήπια αύξηση για να μη γίνεται το παιχνίδι άδικο
+        return 5 + (level - 1) * 2
+
+    # =========================
+    # Σύνολο εχθρών
+    # =========================
+    def enemies_for_level(self, level: int) -> int:
+        """
+        Υπολογίζει το συνολικό πλήθος εχθρών της πίστας.
+
+        Κανόνας:
+        - Στην πίστα 1 υπάρχουν 6 εχθροί
+        - Σε κάθε επόμενη πίστα προστίθενται +2
+        - Οι εχθροί δεν εμφανίζονται όλοι μαζί,
+          αλλά σταδιακά (spawn over time)
+
+        level : ο αριθμός της πίστας
+        επιστρέφει : συνολικό πλήθος εχθρών
+        """
+
+        return 6 + (level - 1) * 2
+
+    # =========================
+    # Ταχύτητα εχθρών
+    # (μέσω delay κίνησης)
+    # =========================
+    def enemy_move_delay(self, level: int) -> float:
+        """
+        Υπολογίζει το delay μεταξύ δύο κινήσεων εχθρού.
+
+        Σημαντικό:
+        - Μικρότερο delay σημαίνει πιο γρήγοροι εχθροί
+        - Η ταχύτητα αυξάνεται προοδευτικά
+        - Υπάρχει κατώτατο όριο για λόγους ισορροπίας
+
+        level : ο αριθμός της πίστας
+        επιστρέφει : delay σε δευτερόλεπτα
+        """
+
+        # Αρχικό delay στην πίστα 1
+        base_delay = 0.45
+
+        # Μείωση delay ανά πίστα
+        reduction = (level - 1) * 0.015
+
+        # Δεν επιτρέπουμε να πέσει κάτω από 0.18
+        # για να μην γίνει το παιχνίδι non playable
+        return max(0.18, base_delay - reduction)
+
+    # =========================
+    # Υπάρχει επόμενη πίστα;
+    # =========================
+    def has_next_level(self, level: int) -> bool:
+        """
+        Ελέγχει αν υπάρχει επόμενη πίστα.
+
+        level : τρέχουσα πίστα
+        επιστρέφει :
+        - True  αν υπάρχει επόμενη
+        - False αν έχουμε φτάσει στο MAX_LEVEL
+        """
+
+        return level < self.MAX_LEVEL
Index: shared/services/enemy_spawner.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/enemy_spawner.py b/shared/services/enemy_spawner.py
--- a/shared/services/enemy_spawner.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/enemy_spawner.py	(date 1767631102495)
@@ -1,0 +1,71 @@
+import random
+# Χρησιμοποιείται για την τυχαία επιλογή σημείου εμφάνισης εχθρού
+
+from shared.model.enemy import Enemy
+# Εισάγουμε την κλάση Enemy, δηλαδή το αντικείμενο του εχθρού του παιχνιδιού
+
+from shared.model.types import MonsterForm
+# Εισάγουμε τον τύπο MonsterForm που περιγράφει τη μορφή του εχθρού
+# (π.χ. NOBBIN, HOBBIN κ.λπ.)
+
+
+class EnemySpawner:
+    """
+    Η κλάση EnemySpawner είναι υπεύθυνη αποκλειστικά
+    για τη δημιουργία (spawn) εχθρών στο παιχνίδι.
+
+    Δεν ελέγχει AI, κίνηση ή συγκρούσεις.
+    Απλώς:
+    - επιλέγει ένα σημείο spawn
+    - δημιουργεί έναν Enemy
+    - ορίζει την αρχική του μορφή
+    """
+
+    def __init__(self, spawn_x, spawn_y):
+        """
+        Αρχικοποιεί το σύστημα δημιουργίας εχθρών.
+
+        spawn_x, spawn_y:
+        οι αρχικές συντεταγμένες (tile-based) όπου μπορούν
+        να εμφανιστούν εχθροί.
+        """
+
+        # Η λίστα spawn_points περιέχει όλα τα επιτρεπτά σημεία εμφάνισης
+        # Κάθε στοιχείο είναι ένα tuple (x, y)
+        self.spawn_points = [(spawn_x, spawn_y)]
+
+    def add_spawn_point(self, x, y):
+        """
+        Προσθέτει ένα νέο σημείο εμφάνισης εχθρών.
+
+        Αυτό επιτρέπει στο παιχνίδι να έχει:
+        - πολλαπλά spawn σημεία
+        - πιο απρόβλεπτη συμπεριφορά εχθρών
+        """
+
+        # Προσθέτουμε το νέο σημείο στη λίστα
+        self.spawn_points.append((x, y))
+
+    def spawn(self):
+        """
+        Δημιουργεί και επιστρέφει έναν νέο εχθρό.
+
+        Βήματα:
+        1. Επιλέγει τυχαία ένα σημείο spawn
+        2. Δημιουργεί αντικείμενο Enemy
+        3. Ορίζει την αρχική μορφή του εχθρού
+        4. Επιστρέφει τον εχθρό στο game loop
+        """
+
+        # Επιλέγουμε τυχαία ένα από τα διαθέσιμα spawn points
+        x, y = random.choice(self.spawn_points)
+
+        # Δημιουργούμε νέο Enemy στη θέση (x, y)
+        enemy = Enemy("enemy", x, y)
+
+        # Ορίζουμε ότι ο εχθρός ξεκινά ως NOBBIN
+        # (δηλαδή η βασική, λιγότερο επικίνδυνη μορφή)
+        enemy.form = MonsterForm.NOBBIN
+
+        # Επιστρέφουμε τον έτοιμο εχθρό
+        return enemy
Index: shared/services/score_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/score_system.py b/shared/services/score_system.py
--- a/shared/services/score_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/score_system.py	(date 1767630781377)
@@ -1,0 +1,72 @@
+from shared.model.types import TileType
+# Εισάγουμε το TileType enum, το οποίο περιγράφει τα είδη πλακιδίων
+# του επιπέδου (π.χ. χώμα, τούνελ, διαμάντι κ.λπ.).
+
+from shared.services.audio_manager import AudioManager
+# Εισάγουμε τον AudioManager, ο οποίος είναι υπεύθυνος
+# για την αναπαραγωγή ηχητικών εφέ στο παιχνίδι.
+
+
+class ScoreSystem:
+    """
+    Η κλάση ScoreSystem είναι υπεύθυνη για τη διαχείριση
+    του σκορ του παίκτη.
+
+    Περιλαμβάνει λογική που:
+    - αυξάνει το σκορ όταν ο παίκτης συλλέγει αντικείμενα
+    - προσθέτει πόντους από άλλες ενέργειες (π.χ. εξόντωση εχθρών)
+    """
+
+    def __init__(self, score):
+        """
+        Constructor της κλάσης.
+
+        score : αντικείμενο τύπου Score,
+        το οποίο αποθηκεύει και διαχειρίζεται τους πόντους του παίκτη.
+        """
+
+        # Αποθηκεύουμε αναφορά στο αντικείμενο Score
+        self.score = score
+
+    def on_player_enter(self, player, level):
+        """
+        Καλείται όταν ο παίκτης εισέρχεται σε νέο πλακίδιο.
+
+        player : ο παίκτης που κινείται
+        level  : το επίπεδο που περιέχει τα πλακίδια
+        """
+
+        # Παίρνουμε το είδος του πλακιδίου
+        # στη θέση που βρίσκεται ο παίκτης
+        tile = level.get_tile(player.tile_x, player.tile_y)
+
+        # Ελέγχουμε αν το πλακίδιο είναι διαμάντι (EMERALD)
+        if tile == TileType.EMERALD:
+
+            # Μετατρέπουμε το πλακίδιο σε τούνελ,
+            # ώστε το διαμάντι να θεωρηθεί συλλεγμένο
+            level.set_tile(
+                player.tile_x,
+                player.tile_y,
+                TileType.TUNNEL
+            )
+
+            # Αυξάνουμε το σκορ του παίκτη
+            # μέσω της λογικής που ορίζεται στο αντικείμενο Score
+            self.score.add_emerald()
+
+            # Αναπαράγουμε ηχητικό εφέ για την επιβεβαίωση της συλλογής
+            AudioManager.play_sound("menu_select")
+
+    def add_points(self, points: int):
+        """
+        Προσθέτει έναν αυθαίρετο αριθμό πόντων στο σκορ.
+
+        Χρησιμοποιείται σε περιπτώσεις όπως:
+        - εξόντωση εχθρού
+        - συλλογή χρυσού
+        - bonus ανταμοιβές
+        """
+
+        # Αυξάνουμε απευθείας τους συνολικούς πόντους
+        self.score.points += points
Index: shared/services/gold_bag_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/gold_bag_system.py b/shared/services/gold_bag_system.py
--- a/shared/services/gold_bag_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/gold_bag_system.py	(date 1767630993227)
@@ -1,0 +1,138 @@
+from shared.model.types import TileType
+# Εισάγουμε το TileType enum, το οποίο ορίζει
+# τα είδη πλακιδίων του επιπέδου (TUNNEL, GOLD_BAG κ.λπ.)
+
+
+class GoldBagSystem:
+    """
+    Το GoldBagSystem είναι υπεύθυνο για τη συμπεριφορά των σακιών χρυσού.
+
+    Συγκεκριμένα:
+    - ελέγχει πότε ένα σακί πρέπει να αρχίσει να πέφτει
+    - διαχειρίζεται την κίνηση κατά την πτώση
+    - αποφασίζει πότε η πτώση σταματά
+    - μετατρέπει το σακί σε χρυσό (gold pile) όταν ολοκληρωθεί η πτώση
+
+    Το σύστημα αυτό υλοποιεί πιστά τη λογική του κλασικού παιχνιδιού Digger.
+    """
+
+    # Καθυστέρηση μεταξύ δύο διαδοχικών κινήσεων πτώσης
+    # Έχει οριστεί ίδια με το tempo της grid-based κίνησης του παίκτη
+    FALL_DELAY = 0.12
+
+    def __init__(self):
+        """
+        Constructor της κλάσης.
+
+        Δημιουργεί ένα λεξικό timers, ένα για κάθε σακί χρυσού,
+        ώστε κάθε σακί να μπορεί να πέφτει ανεξάρτητα από τα υπόλοιπα.
+        """
+
+        # Λεξικό: bag_id -> χρονόμετρο πτώσης
+        self._fall_timers = {}
+
+    def update(self, gold_bags, level, dt):
+        """
+        Ενημερώνει την κατάσταση όλων των σακιών χρυσού.
+
+        gold_bags : λίστα με αντικείμενα GoldBag
+        level     : το επίπεδο του παιχνιδιού
+        dt        : χρόνος που πέρασε από το προηγούμενο frame
+        """
+
+        # Εξετάζουμε κάθε σακί χρυσού ξεχωριστά
+        for bag in gold_bags:
+
+            # Αν το σακί έχει ήδη συλλεχθεί,
+            # δεν το επεξεργαζόμαστε άλλο
+            if bag.collected:
+                continue
+
+            bag_id = bag.id
+
+            # Αν δεν υπάρχει timer για αυτό το σακί,
+            # δημιουργούμε έναν νέο
+            if bag_id not in self._fall_timers:
+                self._fall_timers[bag_id] = 0.0
+
+            # ==================================================
+            # ΠΕΡΙΠΤΩΣΗ 1: ΤΟ ΣΑΚΙ ΠΕΦΤΕΙ
+            # ==================================================
+            if bag.falling:
+
+                # Αυξάνουμε το χρονόμετρο πτώσης
+                self._fall_timers[bag_id] += dt
+
+                # Ελέγχουμε αν πέρασε ο απαιτούμενος χρόνος
+                if self._fall_timers[bag_id] >= self.FALL_DELAY:
+
+                    # Επαναφέρουμε το timer
+                    self._fall_timers[bag_id] = 0.0
+
+                    # Παίρνουμε το πλακίδιο ακριβώς από κάτω
+                    below_tile = level.get_tile(
+                        bag.tile_x,
+                        bag.tile_y + 1
+                    )
+
+                    # ---------- Συνεχίζει να πέφτει ----------
+                    if below_tile == TileType.TUNNEL:
+
+                        # Καθαρίζουμε το τρέχον πλακίδιο
+                        level.set_tile(
+                            bag.tile_x,
+                            bag.tile_y,
+                            TileType.TUNNEL
+                        )
+
+                        # Αποθηκεύουμε την προηγούμενη y θέση
+                        # (χρησιμοποιείται για συγκρούσεις με εχθρούς)
+                        bag.prev_tile_y = bag.tile_y
+
+                        # Μετακινούμε το σακί ένα πλακίδιο κάτω
+                        bag.tile_y += 1
+
+                        # Τοποθετούμε το σακί στη νέα θέση
+                        level.set_tile(
+                            bag.tile_x,
+                            bag.tile_y,
+                            TileType.GOLD_BAG
+                        )
+
+                    # ---------- Η πτώση σταματά ----------
+                    else:
+                        # Το σακί σταματά να πέφτει
+                        bag.falling = False
+
+                        # Μετατρέπεται σε gold pile
+                        bag.is_gold = True
+
+                        # Καθαρίζουμε το πλακίδιο
+                        level.set_tile(
+                            bag.tile_x,
+                            bag.tile_y,
+                            TileType.TUNNEL
+                        )
+
+                # Αφού επεξεργαστήκαμε την πτώση,
+                # συνεχίζουμε στο επόμενο σακί
+                continue
+
+            # ==================================================
+            # ΠΕΡΙΠΤΩΣΗ 2: ΕΝΑΡΞΗ ΠΤΩΣΗΣ
+            # ==================================================
+            below = level.get_tile(bag.tile_x, bag.tile_y + 1)
+
+            # Αν κάτω υπάρχει τούνελ και το σακί
+            # δεν έχει ήδη μετατραπεί σε χρυσό
+            if below == TileType.TUNNEL and not bag.is_gold:
+
+                # Ξεκινά η πτώση
+                bag.falling = True
+
+                # Αποθηκεύουμε την αρχική y θέση
+                # (ΑΠΑΡΑΙΤΗΤΟ για έλεγχο συντριβής εχθρών)
+                bag.prev_tile_y = bag.tile_y
+
+                # Μηδενίζουμε το timer πτώσης
+                self._fall_timers[bag_id] = 0.0
Index: shared/services/grid_movement.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/grid_movement.py b/shared/services/grid_movement.py
--- a/shared/services/grid_movement.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/grid_movement.py	(date 1767630927896)
@@ -1,0 +1,75 @@
+from shared.model.types import Direction
+# Εισάγουμε το enum Direction, το οποίο ορίζει
+# τις επιτρεπτές κατευθύνσεις κίνησης (UP, DOWN, LEFT, RIGHT).
+
+
+# Πίνακας αντιστοίχισης κατεύθυνσης → μετατόπιση στο grid
+# Κάθε κατεύθυνση μεταφράζεται σε (dx, dy)
+# όπου:
+#   dx = μεταβολή στον άξονα x (στήλες)
+#   dy = μεταβολή στον άξονα y (γραμμές)
+DIR_VECTORS = {
+    Direction.UP: (0, -1),     # πάνω: ίδια στήλη, μία γραμμή πάνω
+    Direction.DOWN: (0, 1),    # κάτω: ίδια στήλη, μία γραμμή κάτω
+    Direction.LEFT: (-1, 0),   # αριστερά: μία στήλη αριστερά
+    Direction.RIGHT: (1, 0),   # δεξιά: μία στήλη δεξιά
+}
+
+
+class GridMovementSystem:
+    """
+    Το GridMovementSystem είναι υπεύθυνο για την κίνηση
+    οντοτήτων μέσα σε ένα grid (πλέγμα πλακιδίων).
+
+    Δεν γνωρίζει:
+    - αν η οντότητα είναι παίκτης ή εχθρός
+    - τι υπάρχει στο πλακίδιο
+    - αν η κίνηση είναι «καλή» ή «κακή» για το gameplay
+
+    Ασχολείται αποκλειστικά με:
+    - τον υπολογισμό της νέας θέσης
+    - τον έλεγχο ορίων του επιπέδου
+    """
+
+    def try_move(self, entity, direction, level):
+        """
+        Προσπαθεί να μετακινήσει μια οντότητα κατά ένα πλακίδιο.
+
+        entity    : το αντικείμενο που κινείται (Player, Enemy κ.λπ.)
+        direction : κατεύθυνση κίνησης (Direction enum)
+        level     : το επίπεδο του παιχνιδιού (χρησιμοποιείται για έλεγχο ορίων)
+
+        Επιστρέφει:
+        - True  αν η κίνηση πραγματοποιήθηκε
+        - False αν η κίνηση απορρίφθηκε
+        """
+
+        # Αν η κατεύθυνση δεν είναι έγκυρη,
+        # δεν επιχειρούμε καν κίνηση
+        if direction not in DIR_VECTORS:
+            return False
+
+        # Παίρνουμε το διάνυσμα κίνησης (dx, dy)
+        dx, dy = DIR_VECTORS[direction]
+
+        # Υπολογίζουμε τη νέα θέση στο grid
+        nx = entity.tile_x + dx
+        ny = entity.tile_y + dy
+
+        # Ελέγχουμε αν η νέα θέση βρίσκεται εντός των ορίων του επιπέδου
+        if not level.in_bounds(nx, ny):
+            return False
+
+        # Αν φτάσαμε εδώ, η κίνηση επιτρέπεται
+        # Ενημερώνουμε τις συντεταγμένες της οντότητας
+        entity.tile_x = nx
+        entity.tile_y = ny
+
+        # Αν η οντότητα διαθέτει ιδιότητα "direction"
+        # (π.χ. Player, αλλά όχι απαραίτητα Enemy),
+        # αποθηκεύουμε τη φορά που κοιτάζει
+        if hasattr(entity, "direction"):
+            entity.direction = direction
+
+        # Δηλώνουμε επιτυχία κίνησης
+        return True
Index: shared/services/enemy_form_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/enemy_form_system.py b/shared/services/enemy_form_system.py
--- a/shared/services/enemy_form_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/enemy_form_system.py	(date 1767631164686)
@@ -1,0 +1,84 @@
+import random
+# Χρησιμοποιείται για την παραγωγή τυχαίων χρονικών διαστημάτων
+# μεταξύ των αλλαγών μορφής του εχθρού
+
+from shared.model.types import MonsterForm
+# Εισάγουμε το enum MonsterForm που περιγράφει τη μορφή του εχθρού
+# (π.χ. NOBBIN, HOBBIN)
+
+
+class EnemyFormSystem:
+    """
+    Το EnemyFormSystem είναι υπεύθυνο για τη δυναμική αλλαγή
+    της μορφής ενός εχθρού κατά τη διάρκεια του παιχνιδιού.
+
+    Συγκεκριμένα:
+    - Εναλλάσσει τον εχθρό μεταξύ NOBBIN και HOBBIN
+    - Η αλλαγή γίνεται μετά από τυχαίο χρονικό διάστημα
+    - Η λογική είναι ανεξάρτητη από AI, κίνηση ή collisions
+    """
+
+    def __init__(self):
+        """
+        Constructor του συστήματος.
+        Δεν απαιτεί αρχικοποίηση μεταβλητών, επειδή
+        τα timers αποθηκεύονται δυναμικά πάνω στο αντικείμενο enemy.
+        """
+        pass
+
+    def update(self, enemy, dt):
+        """
+        Ενημερώνει την κατάσταση της μορφής ενός εχθρού.
+
+        enemy : το αντικείμενο Enemy που ενημερώνουμε
+        dt    : ο χρόνος (σε δευτερόλεπτα) που πέρασε από το προηγούμενο frame
+        """
+
+        # ==================================================
+        # SAFE INITIALIZATION
+        # ==================================================
+
+        # Αν ο εχθρός δεν έχει ακόμα χρονόμετρο μορφής,
+        # το δημιουργούμε δυναμικά (πρώτο update)
+        if not hasattr(enemy, "form_timer"):
+            enemy.form_timer = 0.0
+
+        # Αν δεν υπάρχει προγραμματισμένος χρόνος αλλαγής μορφής,
+        # δημιουργούμε έναν τυχαίο (μεταξύ 4 και 9 δευτερολέπτων)
+        if not hasattr(enemy, "next_form_change"):
+            enemy.next_form_change = random.uniform(4.0, 9.0)
+
+        # ==================================================
+        # UPDATE TIMER
+        # ==================================================
+
+        # Αυξάνουμε τον μετρητή χρόνου με βάση το dt
+        enemy.form_timer += dt
+
+        # Αν δεν έχει φτάσει ακόμα ο χρόνος αλλαγής μορφής,
+        # σταματάμε εδώ και δεν κάνουμε τίποτα άλλο
+        if enemy.form_timer < enemy.next_form_change:
+            return
+
+        # ==================================================
+        # TOGGLE FORM
+        # ==================================================
+
+        # Αν ο εχθρός είναι NOBBIN,
+        # μετατρέπεται σε HOBBIN (πιο επικίνδυνη μορφή)
+        if enemy.form == MonsterForm.NOBBIN:
+            enemy.form = MonsterForm.HOBBIN
+        else:
+            # Αν είναι ήδη HOBBIN,
+            # επιστρέφει στη βασική μορφή NOBBIN
+            enemy.form = MonsterForm.NOBBIN
+
+        # ==================================================
+        # RESET TIMERS
+        # ==================================================
+
+        # Μηδενίζουμε τον μετρητή χρόνου
+        enemy.form_timer = 0.0
+
+        # Ορίζουμε νέο τυχαίο χρόνο για την επόμενη αλλαγή μορφής
+        enemy.next_form_change = random.uniform(4.0, 9.0)
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"1f4a96bc-2fa0-4d87-a283-7b223ec69ccd\" name=\"Changes\" comment=\"\" />\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ProjectColorInfo\"><![CDATA[{\r\n  \"associatedIndex\": 8\r\n}]]></component>\r\n  <component name=\"ProjectId\" id=\"37QhmMao1GYF4q6dgajzisQPyDD\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"RunOnceActivity.typescript.service.memoryLimit.init\": \"true\",\r\n    \"com.intellij.ml.llm.matterhorn.ej.ui.settings.DefaultModelSelectionForGA.v1\": \"true\",\r\n    \"junie.onboarding.icon.badge.shown\": \"true\",\r\n    \"to.speed.mode.migration.done\": \"true\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-9b0f141eb926-JavaScript-PY-253.29346.142\" />\r\n        <option value=\"bundled-python-sdk-f2b7a9f6281b-6e1f45a539f7-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-253.29346.142\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"1f4a96bc-2fa0-4d87-a283-7b223ec69ccd\" name=\"Changes\" comment=\"\" />\r\n      <created>1766841359228</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1766841359228</updated>\r\n    </task>\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/.idea/workspace.xml	(date 1767651362197)
@@ -1,15 +1,91 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
+  <component name="AutoImportSettings">
+    <option name="autoReloadType" value="SELECTIVE" />
+  </component>
   <component name="ChangeListManager">
-    <list default="true" id="1f4a96bc-2fa0-4d87-a283-7b223ec69ccd" name="Changes" comment="" />
+    <list default="true" id="1f4a96bc-2fa0-4d87-a283-7b223ec69ccd" name="Changes" comment="">
+      <change beforePath="$PROJECT_DIR$/.idea/digger.iml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/digger.iml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/app.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/app.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/assets/menu/menu_bg.png" beforeDir="false" afterPath="$PROJECT_DIR$/client/assets/menu/menu_bg.png" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/assets/sprites/digger_player.png" beforeDir="false" afterPath="$PROJECT_DIR$/client/assets/sprites/digger_player.png" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/controllers/input_controller.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/controllers/input_controller.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/input/input_manager.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/input/input_manager.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/main.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/main.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/camera.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/camera.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/effects/explosion.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/effects/explosion.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/scenes/game_scene.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/scenes/game_scene.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/scenes/gameover_scene.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/scenes/gameover_scene.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/scenes/highscores_scene.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/scenes/highscores_scene.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/scenes/how_to_play_scene.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/scenes/how_to_play_scene.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/scenes/main_menu_scene.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/scenes/main_menu_scene.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/scenes/settings_scene.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/scenes/settings_scene.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/sprites/emerald_sprite.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/sprites/emerald_sprite.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/sprites/enemy_sprite.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/sprites/enemy_sprite.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/sprites/gold_bag_sprite.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/sprites/gold_bag_sprite.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/sprites/player_sprite.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/sprites/player_sprite.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/client/views/tilemap_view.py" beforeDir="false" afterPath="$PROJECT_DIR$/client/views/tilemap_view.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/ai/enemy_brain.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/ai/enemy_brain.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/config/game_config.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/config/game_config.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/core/scene.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/core/scene.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/input/input_snapshot.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/input/input_snapshot.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/bullet.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/bullet.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/enemy.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/enemy.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/entity.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/entity.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/gold_bag.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/gold_bag.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/level.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/level.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/lives.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/lives.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/player.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/player.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/score.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/score.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/types.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/types.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/model/weapon.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/model/weapon.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/persistence/score_repository.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/persistence/score_repository.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/audio_manager.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/audio_manager.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/bullet_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/bullet_system.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/difficulty_scaler.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/difficulty_scaler.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/enemy_ai_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/enemy_ai_system.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/enemy_form_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/enemy_form_system.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/enemy_spawner.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/enemy_spawner.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/gold_bag_push_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/gold_bag_push_system.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/gold_bag_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/gold_bag_system.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/grid_movement.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/grid_movement.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/hobbin_digging_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/hobbin_digging_system.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/input.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/input.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/score_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/score_system.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/tile_interaction.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/tile_interaction.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/shared/services/weapon_system.py" beforeDir="false" afterPath="$PROJECT_DIR$/shared/services/weapon_system.py" afterDir="false" />
+    </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
     <option name="LAST_RESOLUTION" value="IGNORE" />
   </component>
-  <component name="ProjectColorInfo"><![CDATA[{
-  "associatedIndex": 8
+  <component name="FileTemplateManagerImpl">
+    <option name="RECENT_TEMPLATES">
+      <list>
+        <option value="Python Script" />
+      </list>
+    </option>
+  </component>
+  <component name="Git.Settings">
+    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
+  </component>
+  <component name="GitHubPullRequestSearchHistory"><![CDATA[{
+  "lastFilter": {
+    "state": "OPEN",
+    "assignee": "cstergio"
+  }
+}]]></component>
+  <component name="GithubPullRequestsUISettings"><![CDATA[{
+  "selectedUrlAndAccountId": {
+    "url": "https://github.com/cstergio/digger.git",
+    "accountId": "95f7722a-25fa-4dc9-b64e-a08e12c31496"
+  }
 }]]></component>
+  <component name="ProjectColorInfo">{
+  &quot;associatedIndex&quot;: 8
+}</component>
   <component name="ProjectId" id="37QhmMao1GYF4q6dgajzisQPyDD" />
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
@@ -17,14 +93,72 @@
   </component>
   <component name="PropertiesComponent"><![CDATA[{
   "keyToString": {
+    "ModuleVcsDetector.initialDetectionPerformed": "true",
+    "Python.main.executor": "Run",
     "RunOnceActivity.ShowReadmeOnStart": "true",
+    "RunOnceActivity.TerminalTabsStorage.copyFrom.TerminalArrangementManager.252": "true",
+    "RunOnceActivity.git.unshallow": "true",
     "RunOnceActivity.typescript.service.memoryLimit.init": "true",
+    "ai.playground.ignore.import.keys.banner.in.settings": "true",
     "com.intellij.ml.llm.matterhorn.ej.ui.settings.DefaultModelSelectionForGA.v1": "true",
+    "git-widget-placeholder": "master",
+    "ignore.virus.scanning.warn.message": "true",
     "junie.onboarding.icon.badge.shown": "true",
+    "last_opened_file_path": "C:/Users/Charis/PycharmProjects/digger/client/assets/menu",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)",
+    "nodejs_package_manager_path": "npm",
     "to.speed.mode.migration.done": "true",
     "vue.rearranger.settings.migration": "true"
   }
 }]]></component>
+  <component name="RecentsManager">
+    <key name="CopyFile.RECENT_KEYS">
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\assets\menu" />
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\assets\audio" />
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\assets\sprites" />
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\views\sprites" />
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\assets\tiles" />
+    </key>
+    <key name="MoveFile.RECENT_KEYS">
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\assets\menu" />
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\assets\sprites" />
+      <recent name="C:\Users\Charis\PycharmProjects\digger\client\views\sprites" />
+    </key>
+  </component>
+  <component name="RunManager">
+    <configuration name="main" type="PythonConfigurationType" factoryName="Python" temporary="true" nameIsGenerated="true">
+      <module name="digger" />
+      <option name="ENV_FILES" value="" />
+      <option name="INTERPRETER_OPTIONS" value="" />
+      <option name="PARENT_ENVS" value="true" />
+      <envs>
+        <env name="PYTHONUNBUFFERED" value="1" />
+      </envs>
+      <option name="SDK_HOME" value="" />
+      <option name="WORKING_DIRECTORY" value="$PROJECT_DIR$/client" />
+      <option name="IS_MODULE_SDK" value="true" />
+      <option name="ADD_CONTENT_ROOTS" value="true" />
+      <option name="ADD_SOURCE_ROOTS" value="true" />
+      <EXTENSION ID="PythonCoverageRunConfigurationExtension" runner="coverage.py" />
+      <option name="RUN_TOOL" value="" />
+      <option name="SCRIPT_NAME" value="$PROJECT_DIR$/client/main.py" />
+      <option name="PARAMETERS" value="" />
+      <option name="SHOW_COMMAND_LINE" value="false" />
+      <option name="EMULATE_TERMINAL" value="false" />
+      <option name="MODULE_MODE" value="false" />
+      <option name="REDIRECT_INPUT" value="false" />
+      <option name="INPUT_FILE" value="" />
+      <method v="2" />
+    </configuration>
+    <recent_temporary>
+      <list>
+        <item itemvalue="Python.main" />
+      </list>
+    </recent_temporary>
+  </component>
   <component name="SharedIndexes">
     <attachedChunks>
       <set>
@@ -40,10 +174,27 @@
       <option name="number" value="Default" />
       <option name="presentableId" value="Default" />
       <updated>1766841359228</updated>
+      <workItem from="1766841360258" duration="37870000" />
+      <workItem from="1766994202421" duration="43342000" />
+      <workItem from="1767458104198" duration="48448000" />
     </task>
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
     <option name="version" value="3" />
   </component>
+  <component name="Vcs.Log.Tabs.Properties">
+    <option name="TAB_STATES">
+      <map>
+        <entry key="MAIN">
+          <value>
+            <State />
+          </value>
+        </entry>
+      </map>
+    </option>
+  </component>
+  <component name="com.intellij.coverage.CoverageDataManagerImpl">
+    <SUITE FILE_PATH="coverage/digger$main.coverage" NAME="main Coverage Results" MODIFIED="1767638530016" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$/client" />
+  </component>
 </project>
\ No newline at end of file
Index: .idea/digger.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\" />\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/digger.iml b/.idea/digger.iml
--- a/.idea/digger.iml	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/.idea/digger.iml	(date 1766841365400)
@@ -1,8 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="inheritedJdk" />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/.venv" />
+    </content>
+    <orderEntry type="jdk" jdkName="Python 3.12 (digger)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
 </module>
\ No newline at end of file
Index: shared/services/enemy_ai_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/enemy_ai_system.py b/shared/services/enemy_ai_system.py
--- a/shared/services/enemy_ai_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/enemy_ai_system.py	(date 1767631212952)
@@ -1,0 +1,54 @@
+class EnemyAISystem:
+    """
+    Το EnemyAISystem είναι το σύστημα τεχνητής νοημοσύνης των εχθρών.
+
+    Ρόλος του:
+    - Συντονίζει την απόφαση κίνησης των εχθρών
+    - Χρησιμοποιεί ένα εξωτερικό αντικείμενο 'brain' για τη λήψη αποφάσεων
+    - Εφαρμόζει την απόφαση μέσω του συστήματος κίνησης
+
+    Σημαντικό:
+    Το EnemyAISystem ΔΕΝ περιέχει τη λογική απόφασης.
+    Αυτή βρίσκεται στο EnemyBrain (separation of concerns).
+    """
+
+    def __init__(self, brain):
+        """
+        Constructor του συστήματος AI.
+
+        brain:
+        Αντικείμενο τύπου EnemyBrain που γνωρίζει
+        πώς να αποφασίζει κατεύθυνση κίνησης για έναν εχθρό.
+        """
+
+        # Αποθηκεύουμε το brain ώστε να το χρησιμοποιούμε σε κάθε update
+        self.brain = brain
+
+    def update(self, enemies, player, level, movement_system, game_mode):
+        """
+        Ενημερώνει την τεχνητή νοημοσύνη όλων των εχθρών.
+
+        enemies          : λίστα από αντικείμενα Enemy
+        player           : ο παίκτης-στόχος (ή ο κοντινότερος παίκτης)
+        level            : το επίπεδο του παιχνιδιού
+        movement_system  : σύστημα κίνησης (GridMovementSystem)
+        game_mode        : τρέχουσα κατάσταση παιχνιδιού (π.χ. NORMAL, BONUS)
+        """
+
+        # Διατρέχουμε όλους τους εχθρούς
+        for enemy in enemies:
+
+            # Αν ο εχθρός δεν είναι ζωντανός,
+            # τον αγνοούμε και περνάμε στον επόμενο
+            if not enemy.alive:
+                continue
+
+            # Ζητάμε από το brain να αποφασίσει
+            # προς ποια κατεύθυνση πρέπει να κινηθεί ο εχθρός
+            direction = self.brain.decide(enemy, player, level, game_mode)
+
+            # Αν το brain επέστρεψε έγκυρη κατεύθυνση
+            if direction:
+                # Προσπαθούμε να μετακινήσουμε τον εχθρό
+                # σύμφωνα με τους κανόνες του grid και του επιπέδου
+                movement_system.try_move(enemy, direction, level)
Index: shared/services/audio_manager.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/audio_manager.py b/shared/services/audio_manager.py
--- a/shared/services/audio_manager.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/audio_manager.py	(date 1767631731303)
@@ -1,0 +1,202 @@
+import pygame
+import os
+
+
+class AudioManager:
+    """
+    Η κλάση AudioManager είναι υπεύθυνη για ΟΛΗ τη διαχείριση ήχου του παιχνιδιού.
+
+    Συγκεκριμένα:
+    - φορτώνει ηχητικά εφέ (sound effects)
+    - αναπαράγει ήχους με βάση γεγονότα (menu, πυροβολισμοί, εκρήξεις)
+    - διαχειρίζεται τη μουσική υποβάθρου
+    - υποστηρίζει mute / unmute σε παγκόσμιο επίπεδο
+
+    Η κλάση υλοποιείται ως utility class με classmethods,
+    ώστε να χρησιμοποιείται από οπουδήποτε χωρίς instantiation.
+    """
+
+    # Κατάσταση σίγασης (mute) για ΟΛΟ το παιχνίδι
+    _muted = False
+
+    # Λεξικό που περιέχει όλα τα φορτωμένα ηχητικά εφέ
+    _sounds = {}
+
+    # Δείχνει αν η μουσική έχει ήδη φορτωθεί
+    _music_loaded = False
+
+    # Αποθηκεύει το path της τρέχουσας μουσικής
+    # ώστε να επαναφορτωθεί σε περίπτωση unmute
+    _current_music_path = None
+
+    # Σταθερά έντασης μουσικής (χαμηλή ένταση)
+    MUSIC_VOLUME = 0.12   # 12%
+
+    @classmethod
+    def init(cls):
+        """
+        Αρχικοποιεί το pygame mixer.
+
+        Η μέθοδος ελέγχει πρώτα αν το mixer είναι ήδη ενεργό,
+        ώστε να αποφευχθεί διπλή αρχικοποίηση που μπορεί να
+        προκαλέσει σφάλματα ή παραμορφωμένο ήχο.
+        """
+
+        if not pygame.mixer.get_init():
+            pygame.mixer.init()
+
+    # ==================================================
+    # Φόρτωση ήχων
+    # ==================================================
+
+    @classmethod
+    def load_sounds(cls, base_path):
+        """
+        Φορτώνει όλα τα ηχητικά εφέ του παιχνιδιού.
+
+        base_path:
+        ο φάκελος όπου βρίσκονται τα αρχεία ήχου
+        """
+
+        # Ήχος πλοήγησης στο menu
+        cls._sounds["menu_move"] = pygame.mixer.Sound(
+            os.path.join(base_path, "menu_move.mp3")
+        )
+
+        # Ήχος επιλογής στο menu
+        cls._sounds["menu_select"] = pygame.mixer.Sound(
+            os.path.join(base_path, "menu_select.mp3")
+        )
+
+        # Ήχος πυροβολισμού
+        cls._sounds["shot"] = pygame.mixer.Sound(
+            os.path.join(base_path, "shot.ogg")
+        )
+
+        # Ήχος έκρηξης
+        cls._sounds["explosion"] = pygame.mixer.Sound(
+            os.path.join(base_path, "explosion.ogg")
+        )
+
+        # Σημείωση:
+        # Εδώ μπορεί προαιρετικά να ρυθμιστεί ξεχωριστή ένταση
+        # για κάθε ηχητικό εφέ, αν χρειαστεί.
+
+    # ==================================================
+    # Αναπαραγωγή ηχητικών εφέ
+    # ==================================================
+
+    @classmethod
+    def play_sound(cls, name):
+        """
+        Αναπαράγει ένα ηχητικό εφέ.
+
+        name:
+        το όνομα του ήχου όπως είναι αποθηκευμένο στο λεξικό _sounds
+        """
+
+        # Αν το σύστημα είναι σε mute, δεν παίζεται κανένας ήχος
+        if cls._muted:
+            return
+
+        # Ανακτούμε τον ήχο από το λεξικό
+        sound = cls._sounds.get(name)
+
+        # Αν ο ήχος υπάρχει, τον αναπαράγουμε
+        if sound:
+            sound.play()
+
+    # ==================================================
+    # Διαχείριση μουσικής
+    # ==================================================
+
+    @classmethod
+    def play_music(cls, path, loop=True):
+        """
+        Φορτώνει και αναπαράγει μουσική υποβάθρου.
+
+        path:
+        το αρχείο μουσικής
+
+        loop:
+        αν True, η μουσική επαναλαμβάνεται συνεχώς
+        """
+
+        # Αποθηκεύουμε το path για πιθανό unmute
+        cls._current_music_path = path
+
+        # Αν είναι muted, δεν ξεκινάμε μουσική
+        if cls._muted:
+            return
+
+        # Φορτώνουμε τη μουσική μόνο την πρώτη φορά
+        if not cls._music_loaded:
+            pygame.mixer.music.load(path)
+            cls._music_loaded = True
+
+        # Ορίζουμε ένταση μουσικής
+        pygame.mixer.music.set_volume(cls.MUSIC_VOLUME)
+
+        # Αναπαραγωγή με ή χωρίς loop
+        pygame.mixer.music.play(-1 if loop else 0)
+
+    @classmethod
+    def stop_music(cls):
+        """
+        Σταματά άμεσα τη μουσική υποβάθρου.
+        """
+
+        pygame.mixer.music.stop()
+
+    @classmethod
+    def set_music_volume(cls, volume: float):
+        """
+        Ορίζει την ένταση της μουσικής.
+
+        volume:
+        τιμή από 0.0 έως 1.0
+        """
+
+        # Περιορίζουμε την τιμή στο αποδεκτό εύρος
+        cls.MUSIC_VOLUME = max(0.0, min(1.0, volume))
+        pygame.mixer.music.set_volume(cls.MUSIC_VOLUME)
+
+    # ==================================================
+    # Mute / Unmute
+    # ==================================================
+
+    @classmethod
+    def mute_all(cls):
+        """
+        Θέτει το σύστημα σε κατάσταση mute.
+
+        Σταματά αμέσως τη μουσική.
+        """
+
+        cls._muted = True
+        pygame.mixer.music.stop()
+
+    @classmethod
+    def unmute_all(cls):
+        """
+        Επαναφέρει τον ήχο του παιχνιδιού.
+
+        Αν υπήρχε μουσική πριν το mute,
+        την επαναφορτώνει και την αναπαράγει ξανά.
+        """
+
+        cls._muted = False
+
+        if cls._current_music_path:
+            pygame.mixer.music.load(cls._current_music_path)
+            pygame.mixer.music.set_volume(cls.MUSIC_VOLUME)
+            pygame.mixer.music.play(-1)
+
+    @classmethod
+    def is_muted(cls) -> bool:
+        """
+        Επιστρέφει True αν το σύστημα ήχου είναι muted,
+        αλλιώς False.
+        """
+
+        return cls._muted
Index: shared/services/tile_interaction.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/tile_interaction.py b/shared/services/tile_interaction.py
--- a/shared/services/tile_interaction.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/tile_interaction.py	(date 1767630723543)
@@ -1,0 +1,37 @@
+from shared.model.types import TileType
+# Εισάγουμε το enum TileType, το οποίο περιγράφει
+# τα διαφορετικά είδη πλακιδίων (χώμα, τούνελ, διαμάντι κ.λπ.)
+# που μπορούν να υπάρχουν στο επίπεδο του παιχνιδιού.
+
+
+class TileInteractionSystem:
+    """
+    Η κλάση TileInteractionSystem είναι υπεύθυνη για τις αλληλεπιδράσεις
+    μιας οντότητας (παίκτης ή εχθρός) με το πλακίδιο στο οποίο εισέρχεται.
+
+    Δεν αποφασίζει ποιος κινείται ή πότε, αλλά μόνο τι συμβαίνει
+    όταν μια οντότητα πατήσει σε ένα συγκεκριμένο είδος πλακιδίου.
+    """
+
+    def on_enter(self, entity, level):
+        """
+        Καλείται όταν μια οντότητα εισέρχεται σε νέο πλακίδιο.
+
+        entity : το αντικείμενο που κινείται (π.χ. Player ή Enemy)
+        level  : το επίπεδο του παιχνιδιού που περιέχει το grid πλακιδίων
+        """
+
+        # Παίρνουμε το είδος του πλακιδίου
+        # στη θέση (tile_x, tile_y) της οντότητας
+        tile = level.get_tile(entity.tile_x, entity.tile_y)
+
+        # Ελέγχουμε αν το πλακίδιο είναι χώμα (DIRT)
+        if tile == TileType.DIRT:
+
+            # Αν είναι χώμα, το μετατρέπουμε σε τούνελ (TUNNEL),
+            # δηλαδή θεωρούμε ότι η οντότητα "έσκαψε" το έδαφος
+            level.set_tile(
+                entity.tile_x,     # x θέση στο grid
+                entity.tile_y,     # y θέση στο grid
+                TileType.TUNNEL    # νέο είδος πλακιδίου
+            )
Index: shared/services/input.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/input.py b/shared/services/input.py
--- a/shared/services/input.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/input.py	(date 1767630834169)
@@ -1,0 +1,66 @@
+class InputSnapshot:
+    """
+    Η κλάση InputSnapshot αναπαριστά ένα στιγμιότυπο (snapshot)
+    της εισόδου του παίκτη για ένα και μόνο frame του παιχνιδιού.
+
+    Δημιουργείται από το σύστημα εισόδου (InputController)
+    και περνά αυτούσια στις σκηνές (Scenes), ώστε:
+    - οι σκηνές να μην διαβάζουν απευθείας το πληκτρολόγιο
+    - να υπάρχει καθαρός διαχωρισμός input και game logic
+
+    Το "Immutable-ish" σημαίνει ότι, παρότι τεχνικά τα πεδία
+    μπορούν να αλλάξουν, στη φιλοσοφία του παιχνιδιού
+    αντιμετωπίζεται ως αμετάβλητο αντικείμενο.
+    """
+
+    def __init__(
+        self,
+        up=False,
+        down=False,
+        left=False,
+        right=False,
+        fire=False,
+        pause=False,
+        backspace=False,
+        text="",
+    ):
+        """
+        Constructor της κλάσης InputSnapshot.
+
+        Κάθε παράμετρος αντιστοιχεί σε μία συγκεκριμένη
+        ενέργεια του παίκτη στο τρέχον frame.
+
+        Όλες έχουν default τιμή, ώστε να μπορεί να δημιουργηθεί
+        snapshot ακόμα και χωρίς καμία ενεργή είσοδο.
+        """
+
+        # True αν στο συγκεκριμένο frame πατήθηκε το πλήκτρο "πάνω"
+        self.up = up
+
+        # True αν στο συγκεκριμένο frame πατήθηκε το πλήκτρο "κάτω"
+        self.down = down
+
+        # True αν στο συγκεκριμένο frame πατήθηκε το πλήκτρο "αριστερά"
+        self.left = left
+
+        # True αν στο συγκεκριμένο frame πατήθηκε το πλήκτρο "δεξιά"
+        self.right = right
+
+        # True αν στο συγκεκριμένο frame πατήθηκε το πλήκτρο fire
+        # (π.χ. SPACE για πυροβολισμό)
+        self.fire = fire
+
+        # True αν πατήθηκε το πλήκτρο pause
+        # (π.χ. ESC για επιστροφή στο μενού)
+        self.pause = pause
+
+        # True αν πατήθηκε backspace
+        # Χρησιμοποιείται κυρίως σε σκηνές εισαγωγής κειμένου
+        self.backspace = backspace
+
+        # Κείμενο που πληκτρολογήθηκε στο frame
+        # Χρησιμοποιείται για:
+        # - εισαγωγή ονόματος
+        # - ρυθμίσεις
+        # - high scores
+        self.text = text
Index: shared/services/hobbin_digging_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/hobbin_digging_system.py b/shared/services/hobbin_digging_system.py
--- a/shared/services/hobbin_digging_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/hobbin_digging_system.py	(date 1767630874156)
@@ -1,0 +1,51 @@
+from shared.model.types import TileType, MonsterForm
+# Εισάγουμε:
+# - TileType: τα είδη πλακιδίων του επιπέδου (χώμα, τούνελ, διαμάντι, σακί χρυσού κ.λπ.)
+# - MonsterForm: τη μορφή του τέρατος (π.χ. Nobbin, Hobbin),
+#   η οποία επηρεάζει τη συμπεριφορά του εχθρού
+
+
+class HobbinDiggingSystem:
+    """
+    Το HobbinDiggingSystem υλοποιεί τη λογική σκαψίματος
+    που εφαρμόζεται αποκλειστικά στους εχθρούς τύπου Hobbin.
+
+    Στο παιχνίδι Digger:
+    - οι Nobbin ΔΕΝ μπορούν να σκάψουν
+    - οι Hobbin ΜΠΟΡΟΥΝ να σκάβουν όπως ο παίκτης
+
+    Αυτή η διαφορά υλοποιείται ξεκάθαρα και απομονωμένα
+    σε αυτό το σύστημα.
+    """
+
+    def on_enter(self, enemy, level):
+        """
+        Καλείται όταν ένας εχθρός εισέρχεται σε νέο πλακίδιο.
+
+        enemy : το αντικείμενο Enemy που κινείται
+        level : το επίπεδο του παιχνιδιού (grid πλακιδίων)
+        """
+
+        # Αν ο εχθρός ΔΕΝ είναι Hobbin,
+        # τότε δεν εφαρμόζεται καμία λογική σκαψίματος
+        if enemy.form != MonsterForm.HOBBIN:
+            return
+
+        # Παίρνουμε το είδος του πλακιδίου
+        # στο οποίο μόλις μπήκε ο Hobbin
+        tile = level.get_tile(enemy.tile_x, enemy.tile_y)
+
+        # Αν το πλακίδιο είναι:
+        # - χώμα (DIRT)
+        # - διαμάντι (EMERALD)
+        # - σακί χρυσού (GOLD_BAG)
+        # τότε ο Hobbin το "σκάβει"
+        if tile in (TileType.DIRT, TileType.EMERALD, TileType.GOLD_BAG):
+
+            # Μετατρέπουμε το πλακίδιο σε τούνελ,
+            # όπως ακριβώς κάνει και ο παίκτης
+            level.set_tile(
+                enemy.tile_x,
+                enemy.tile_y,
+                TileType.TUNNEL
+            )
Index: shared/services/gold_bag_push_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/gold_bag_push_system.py b/shared/services/gold_bag_push_system.py
--- a/shared/services/gold_bag_push_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/gold_bag_push_system.py	(date 1767631039644)
@@ -1,0 +1,70 @@
+from shared.model.types import Direction, TileType
+# Εισάγουμε:
+# - Direction: τις κατευθύνσεις κίνησης (LEFT, RIGHT κ.λπ.)
+# - TileType: τα είδη πλακιδίων του επιπέδου (TUNNEL, GOLD_BAG κ.ά.)
+
+
+class GoldBagPushSystem:
+    """
+    Το GoldBagPushSystem είναι υπεύθυνο για το οριζόντιο σπρώξιμο
+    των σακιών χρυσού από παίκτες ή εχθρούς.
+
+    Υλοποιεί αυστηρά τους κανόνες του κλασικού Digger:
+    - Το σπρώξιμο επιτρέπεται ΜΟΝΟ αριστερά ή δεξιά
+    - Το σακί πρέπει να είναι σταθερό (STABLE)
+    - Το πλακίδιο-στόχος πρέπει να είναι τούνελ (TUNNEL)
+    - Η παλιά θέση του σακιού μετατρέπεται σε τούνελ
+    """
+
+    def try_push(self, bag, direction, level) -> bool:
+        """
+        Προσπαθεί να σπρώξει ένα σακί χρυσού οριζόντια.
+
+        bag       : το αντικείμενο GoldBag που επιχειρούμε να μετακινήσουμε
+        direction : κατεύθυνση ώθησης (LEFT ή RIGHT)
+        level     : το επίπεδο του παιχνιδιού (grid πλακιδίων)
+
+        Επιστρέφει:
+        - True  αν το σπρώξιμο πραγματοποιήθηκε
+        - False αν απορρίφθηκε λόγω κανόνων
+        """
+
+        # Αν το σακί δεν είναι σταθερό (π.χ. πέφτει ή έχει γίνει gold),
+        # τότε απαγορεύεται το σπρώξιμο
+        if bag.state != "STABLE":
+            return False
+
+        # Επιτρέπουμε σπρώξιμο μόνο προς τα αριστερά ή δεξιά
+        if direction not in (Direction.LEFT, Direction.RIGHT):
+            return False
+
+        # Υπολογίζουμε τη μετατόπιση στον άξονα x
+        # LEFT  -> -1
+        # RIGHT -> +1
+        dx = -1 if direction == Direction.LEFT else 1
+
+        # Υπολογίζουμε τη θέση-στόχο
+        target_x = bag.tile_x + dx
+        target_y = bag.tile_y
+
+        # Ελέγχουμε αν η νέα θέση βρίσκεται εντός των ορίων του επιπέδου
+        if not level.in_bounds(target_x, target_y):
+            return False
+
+        # Το πλακίδιο-στόχος πρέπει να είναι τούνελ,
+        # αλλιώς το σακί δεν μπορεί να μετακινηθεί
+        if level.get_tile(target_x, target_y) != TileType.TUNNEL:
+            return False
+
+        # ==================================================
+        # AUTHENTIC DIGGER RULE
+        # ==================================================
+        # Η παλιά θέση του σακιού γίνεται τούνελ
+        old_x, old_y = bag.tile_x, bag.tile_y
+        level.set_tile(old_x, old_y, TileType.TUNNEL)
+
+        # Μετακινούμε το σακί στη νέα θέση
+        bag.tile_x = target_x
+
+        # Δηλώνουμε επιτυχία σπρωξίματος
+        return True
Index: shared/persistence/score_repository.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/persistence/score_repository.py b/shared/persistence/score_repository.py
--- a/shared/persistence/score_repository.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/persistence/score_repository.py	(date 1767631494043)
@@ -1,0 +1,126 @@
+import sqlite3
+import os
+from datetime import datetime
+# sqlite3: ενσωματωμένη βιβλιοθήκη της Python για βάσεις δεδομένων SQLite
+# os: για ασφαλή χειρισμό διαδρομών αρχείων
+# datetime: για καταγραφή ημερομηνίας και ώρας επίτευξης score
+
+
+class ScoreRepository:
+    """
+    Η κλάση ScoreRepository είναι υπεύθυνη για την αποθήκευση
+    και ανάκτηση των scores του παιχνιδιού.
+
+    Αποτελεί το επίπεδο πρόσβασης δεδομένων (Data Access Layer)
+    και απομονώνει πλήρως τη λογική της βάσης δεδομένων
+    από το υπόλοιπο παιχνίδι.
+    """
+
+    def __init__(self):
+        """
+        Constructor της κλάσης.
+
+        Δημιουργεί ή ανοίγει τη βάση δεδομένων scores.db
+        και εξασφαλίζει ότι ο πίνακας scores υπάρχει.
+        """
+
+        # Εντοπίζουμε τον φάκελο στον οποίο βρίσκεται το αρχείο αυτό
+        base_dir = os.path.dirname(__file__)
+
+        # Δημιουργούμε τη διαδρομή προς το αρχείο της βάσης
+        db_path = os.path.join(base_dir, "scores.db")
+
+        # Δημιουργούμε σύνδεση με τη βάση δεδομένων SQLite
+        self.conn = sqlite3.connect(db_path)
+
+        # Δημιουργούμε τον πίνακα αν δεν υπάρχει
+        self._create_table()
+
+    def _create_table(self):
+        """
+        Δημιουργεί τον πίνακα scores στη βάση δεδομένων,
+        αν αυτός δεν υπάρχει ήδη.
+        """
+
+        # Δημιουργούμε cursor για εκτέλεση SQL εντολών
+        cur = self.conn.cursor()
+
+        # SQL εντολή δημιουργίας πίνακα
+        cur.execute("""
+            CREATE TABLE IF NOT EXISTS scores (
+                id INTEGER PRIMARY KEY AUTOINCREMENT,
+                name TEXT,
+                score INTEGER,
+                date TEXT,
+                time TEXT
+            )
+        """)
+
+        # Επιβεβαιώνουμε τις αλλαγές στη βάση
+        self.conn.commit()
+
+    def _next_game_name(self) -> str:
+        """
+        Δημιουργεί αυτόματα όνομα παιχνιδιού τύπου:
+        GAME01, GAME02, GAME03, ...
+
+        Το όνομα βασίζεται στο πλήθος των ήδη αποθηκευμένων scores.
+        """
+
+        cur = self.conn.cursor()
+
+        # Μετράμε πόσες εγγραφές υπάρχουν ήδη
+        cur.execute("SELECT COUNT(*) FROM scores")
+        count = cur.fetchone()[0] + 1
+
+        # Επιστρέφουμε το όνομα σε μορφή GAME##
+        return f"GAME{count:02d}"
+
+    def add_score(self, score: int):
+        """
+        Αποθηκεύει ένα νέο score στη βάση δεδομένων.
+
+        score:
+        το τελικό σκορ του παιχνιδιού
+        """
+
+        # Παίρνουμε την τρέχουσα ημερομηνία και ώρα
+        now = datetime.now()
+
+        # Δημιουργούμε αυτόματο όνομα παιχνιδιού
+        name = self._next_game_name()
+
+        cur = self.conn.cursor()
+
+        # Εισάγουμε νέα εγγραφή στον πίνακα scores
+        cur.execute(
+            "INSERT INTO scores (name, score, date, time) VALUES (?, ?, ?, ?)",
+            (
+                name,
+                score,
+                now.strftime("%d/%m/%Y"),
+                now.strftime("%H:%M"),
+            )
+        )
+
+        # Επιβεβαιώνουμε την εισαγωγή
+        self.conn.commit()
+
+    def top_10(self):
+        """
+        Επιστρέφει τα 10 καλύτερα scores
+        ταξινομημένα κατά φθίνουσα σειρά σκορ.
+        """
+
+        cur = self.conn.cursor()
+
+        # SQL ερώτημα για τα κορυφαία 10 scores
+        cur.execute("""
+            SELECT name, date, time, score
+            FROM scores
+            ORDER BY score DESC
+            LIMIT 10
+        """)
+
+        # Επιστρέφουμε όλα τα αποτελέσματα
+        return cur.fetchall()
Index: shared/services/weapon_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/weapon_system.py b/shared/services/weapon_system.py
--- a/shared/services/weapon_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/weapon_system.py	(date 1767630678446)
@@ -1,0 +1,37 @@
+from shared.model.bullet import Bullet
+# Εισάγουμε την κλάση Bullet, η οποία αναπαριστά μια σφαίρα
+# που εκτοξεύεται από τον παίκτη στο παιχνίδι.
+
+
+class WeaponSystem:
+    """
+    Η κλάση WeaponSystem είναι υπεύθυνη για τη λογική χρήσης του όπλου.
+    Συγκεκριμένα, ελέγχει πότε ένας παίκτης μπορεί να πυροβολήσει
+    και δημιουργεί τα αντίστοιχα αντικείμενα Bullet.
+    """
+
+    def try_fire(self, weapon, player, bullets):
+        """
+        Προσπαθεί να εκτελέσει έναν πυροβολισμό.
+
+        weapon  : το αντικείμενο Weapon, που γνωρίζει αν το όπλο είναι έτοιμο να πυροβολήσει
+        player  : ο παίκτης που πυροβολεί (θέση και κατεύθυνση)
+        bullets : λίστα που περιέχει όλες τις ενεργές σφαίρες στο παιχνίδι
+        """
+
+        # Ελέγχουμε αν το όπλο μπορεί να πυροβολήσει (cooldown)
+        # ΚΑΙ αν ο παίκτης έχει κατεύθυνση (δηλαδή κινείται ή έχει κινηθεί)
+        if weapon.can_fire() and player.direction is not None:
+
+            # Δημιουργούμε μια νέα σφαίρα (Bullet)
+            # Η σφαίρα ξεκινά από τη θέση του παίκτη (tile_x, tile_y)
+            # και κινείται προς την κατεύθυνση του παίκτη
+            bullets.append(Bullet(
+                player.tile_x,      # x συντεταγμένη του παίκτη στο grid
+                player.tile_y,      # y συντεταγμένη του παίκτη στο grid
+                player.direction    # κατεύθυνση κίνησης της σφαίρας
+            ))
+
+            # Ενημερώνουμε το όπλο ότι μόλις πυροβόλησε,
+            # ώστε να ξεκινήσει ξανά το cooldown
+            weapon.fired()
Index: shared/services/bullet_system.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/shared/services/bullet_system.py b/shared/services/bullet_system.py
--- a/shared/services/bullet_system.py	(revision 41e0c1e8dd63a1370ed8a25f0e05e0ee0a8e22db)
+++ b/shared/services/bullet_system.py	(date 1767631382800)
@@ -1,0 +1,119 @@
+from shared.model.types import TileType, Direction
+# Εισάγουμε:
+# - TileType: τα είδη πλακιδίων του επιπέδου (DIRT, TUNNEL, GOLD_BAG κ.λπ.)
+# - Direction: τις κατευθύνσεις κίνησης (UP, DOWN, LEFT, RIGHT)
+
+from shared.services.audio_manager import AudioManager
+# Διαχειρίζεται την αναπαραγωγή ήχων (π.χ. έκρηξη)
+
+
+# Λεξικό που αντιστοιχίζει κάθε κατεύθυνση σε μετατόπιση στο grid
+# Χρησιμοποιείται για τη μετακίνηση της σφαίρας ανά frame
+DIR_VECTORS = {
+    Direction.UP: (0, -1),
+    Direction.DOWN: (0, 1),
+    Direction.LEFT: (-1, 0),
+    Direction.RIGHT: (1, 0),
+}
+
+
+class BulletSystem:
+    """
+    Το BulletSystem είναι υπεύθυνο για την ενημέρωση όλων των σφαιρών.
+
+    Αρμοδιότητές του:
+    - Μετακινεί τις σφαίρες στο grid
+    - Ελέγχει αν έληξε ο χρόνος ζωής τους
+    - Ελέγχει συγκρούσεις με το επίπεδο
+    - Ελέγχει συγκρούσεις με εχθρούς
+    - Επιστρέφει ποιοι εχθροί σκοτώθηκαν και από ποιον παίκτη
+
+    Σημαντικό:
+    Το BulletSystem ΔΕΝ αποδίδει πόντους.
+    Αυτό γίνεται σε ανώτερο επίπεδο (GameScene).
+    """
+
+    def update(self, bullets, level, enemies, dt):
+        """
+        Ενημερώνει όλες τις σφαίρες για ένα frame.
+
+        bullets : λίστα αντικειμένων Bullet
+        level   : το επίπεδο του παιχνιδιού
+        enemies : λίστα εχθρών
+        dt      : χρόνος που πέρασε από το προηγούμενο frame
+
+        Επιστρέφει:
+        - λίστα από tuples (enemy, owner_id)
+          ώστε το GameScene να αποδώσει σωστά το σκορ
+        """
+
+        # Λίστα με σφαίρες που πρέπει να αφαιρεθούν
+        to_remove = []
+
+        # Λίστα με σκοτωμούς (enemy, owner_id)
+        kills = []
+
+        # Διατρέχουμε όλες τις ενεργές σφαίρες
+        for bullet in bullets:
+
+            # Ενημερώνουμε την εσωτερική κατάσταση της σφαίρας
+            # (π.χ. διάρκεια ζωής)
+            bullet.update(dt)
+
+            # Αν η σφαίρα έχει λήξει χρονικά
+            if bullet.expired:
+                to_remove.append(bullet)
+                continue
+
+            # Υπολογίζουμε την επόμενη θέση με βάση την κατεύθυνση
+            dx, dy = DIR_VECTORS[bullet.direction]
+            nx = bullet.tile_x + dx
+            ny = bullet.tile_y + dy
+
+            # Αν η σφαίρα βγει εκτός ορίων του επιπέδου
+            if not level.in_bounds(nx, ny):
+                to_remove.append(bullet)
+                continue
+
+            # Ελέγχουμε το πλακίδιο στο οποίο κατευθύνεται
+            tile = level.get_tile(nx, ny)
+
+            # Αν το πλακίδιο είναι συμπαγές (χώμα ή σακί χρυσού),
+            # η σφαίρα σταματά και καταστρέφεται
+            if tile in (TileType.DIRT, TileType.GOLD_BAG):
+                to_remove.append(bullet)
+                continue
+
+            # Μετακινούμε τη σφαίρα στη νέα θέση
+            bullet.tile_x = nx
+            bullet.tile_y = ny
+
+            # Έλεγχος σύγκρουσης με εχθρούς
+            # Δεν αποδίδουμε σκορ εδώ, μόνο δηλώνουμε το kill
+            for enemy in enemies:
+                if enemy.alive and enemy.tile_x == nx and enemy.tile_y == ny:
+
+                    # Ο εχθρός πεθαίνει
+                    enemy.alive = False
+
+                    # Αναπαραγωγή ήχου έκρηξης
+                    AudioManager.play_sound("explosion")
+
+                    # Αναγνωρίζουμε ποιος παίκτης έριξε τη σφαίρα
+                    # Αν δεν υπάρχει owner_id, θεωρούμε τον Player 1
+                    owner = getattr(bullet, "owner_id", "p1")
+
+                    # Καταγράφουμε τον σκοτωμό
+                    kills.append((enemy, owner))
+
+                    # Η σφαίρα καταστρέφεται μετά τη σύγκρουση
+                    to_remove.append(bullet)
+                    break
+
+        # Αφαιρούμε όλες τις σφαίρες που σημειώθηκαν για διαγραφή
+        for b in to_remove:
+            if b in bullets:
+                bullets.remove(b)
+
+        # Επιστρέφουμε τη λίστα σκοτωμών
+        return kills
